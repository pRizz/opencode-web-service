# Plan 14-03: Version Bump Workflow

## Objective

Create a GitHub Actions workflow that automates version bumping, allowing releases to be triggered entirely from the GitHub UI.

## Overview

Add a `workflow_dispatch` triggered workflow that:
1. Accepts bump type (major/minor/patch) as input
2. Calculates new version from current
3. Updates all version files
4. Commits and creates release tag
5. Triggers downstream workflows (publish.yml, docker-publish.yml)

## Prerequisites

- Plan 14-01 complete (docker-publish.yml exists)
- Current release.sh script works locally

## Tasks

### 1. Create Version Bump Workflow

**File:** `.github/workflows/version-bump.yml`

```yaml
name: Version Bump

on:
  workflow_dispatch:
    inputs:
      bump_type:
        description: 'Version bump type'
        required: true
        type: choice
        options:
          - patch
          - minor
          - major
        default: patch

permissions:
  contents: write  # Required for pushing commits and tags

jobs:
  bump-version:
    name: Bump Version
    runs-on: ubuntu-latest

    steps:
      - uses: actions/checkout@v4
        with:
          fetch-depth: 0  # Need full history for version detection
          token: ${{ secrets.GITHUB_TOKEN }}

      - name: Configure Git
        run: |
          git config user.name "github-actions[bot]"
          git config user.email "github-actions[bot]@users.noreply.github.com"

      - name: Get current version
        id: current
        run: |
          # Extract version from root Cargo.toml
          CURRENT=$(grep -m1 '^version = ' Cargo.toml | sed 's/version = "\(.*\)"/\1/')
          echo "version=${CURRENT}" >> "$GITHUB_OUTPUT"
          echo "Current version: ${CURRENT}"

      - name: Calculate new version
        id: new
        run: |
          CURRENT="${{ steps.current.outputs.version }}"
          BUMP_TYPE="${{ inputs.bump_type }}"

          # Parse version components
          IFS='.' read -r MAJOR MINOR PATCH <<< "${CURRENT}"

          case "${BUMP_TYPE}" in
            major)
              NEW_VERSION="$((MAJOR + 1)).0.0"
              ;;
            minor)
              NEW_VERSION="${MAJOR}.$((MINOR + 1)).0"
              ;;
            patch)
              NEW_VERSION="${MAJOR}.${MINOR}.$((PATCH + 1))"
              ;;
          esac

          echo "version=${NEW_VERSION}" >> "$GITHUB_OUTPUT"
          echo "New version: ${NEW_VERSION}"

      - name: Check if tag exists
        run: |
          TAG="release/v${{ steps.new.outputs.version }}"
          if git rev-parse "${TAG}" >/dev/null 2>&1; then
            echo "Error: Tag ${TAG} already exists"
            exit 1
          fi

      - name: Update version files
        run: |
          ./scripts/set-all-versions.sh "${{ steps.new.outputs.version }}"

      - name: Install Rust
        uses: dtolnay/rust-toolchain@master
        with:
          toolchain: "1.88"

      - name: Update Cargo.lock
        run: cargo check --workspace

      - name: Commit version bump
        run: |
          git add -A
          git commit -m "chore(release): v${{ steps.new.outputs.version }}"

      - name: Create release tag
        run: |
          git tag "v${{ steps.new.outputs.version }}"
          git tag "release/v${{ steps.new.outputs.version }}"

      - name: Push changes and tags
        run: |
          git push
          git push origin "v${{ steps.new.outputs.version }}"
          git push origin "release/v${{ steps.new.outputs.version }}"

      - name: Summary
        run: |
          echo "## ðŸŽ‰ Version Bumped!" >> $GITHUB_STEP_SUMMARY
          echo "" >> $GITHUB_STEP_SUMMARY
          echo "- **Previous:** ${{ steps.current.outputs.version }}" >> $GITHUB_STEP_SUMMARY
          echo "- **New:** ${{ steps.new.outputs.version }}" >> $GITHUB_STEP_SUMMARY
          echo "- **Bump type:** ${{ inputs.bump_type }}" >> $GITHUB_STEP_SUMMARY
          echo "" >> $GITHUB_STEP_SUMMARY
          echo "### Next Steps" >> $GITHUB_STEP_SUMMARY
          echo "" >> $GITHUB_STEP_SUMMARY
          echo "The following workflows will now run automatically:" >> $GITHUB_STEP_SUMMARY
          echo "- **Publish:** Publishes to crates.io and npm" >> $GITHUB_STEP_SUMMARY
          echo "- **Docker Publish:** Builds and pushes Docker image to GHCR" >> $GITHUB_STEP_SUMMARY
```

### 2. Update publish.yml to Also Trigger on v* Tags

**File:** `.github/workflows/publish.yml`

Update trigger to accept both tag formats:

```yaml
on:
  push:
    tags:
      - 'release/v*'
      - 'v*'  # Also match simple v* tags
```

This allows downstream workflows to be triggered by either tag format.

### 3. Update docker-publish.yml Similarly

**File:** `.github/workflows/docker-publish.yml`

```yaml
on:
  push:
    tags:
      - 'release/v*'
      - 'v*'

# ... and update version extraction to handle both formats:
- name: Extract version from tag
  id: version
  run: |
    # Handle both release/vX.Y.Z and vX.Y.Z formats
    TAG="${GITHUB_REF_NAME}"
    VERSION="${TAG#release/}"  # Remove release/ prefix if present
    VERSION="${VERSION#v}"     # Remove v prefix
    echo "version=${VERSION}" >> "$GITHUB_OUTPUT"
    echo "Building version: ${VERSION}"
```

### 4. Create GitHub Release (Optional Enhancement)

Add step to create GitHub Release with release notes:

```yaml
- name: Create GitHub Release
  uses: softprops/action-gh-release@v2
  with:
    tag_name: "v${{ steps.new.outputs.version }}"
    name: "v${{ steps.new.outputs.version }}"
    body: |
      ## What's Changed

      See [full changelog](https://github.com/pRizz/opencode-cloud/compare/v${{ steps.current.outputs.version }}...v${{ steps.new.outputs.version }})

      ## Installation

      ```bash
      # Via cargo
      cargo install opencode-cloud

      # Via npm
      npx opencode-cloud --version

      # Via Docker
      docker pull ghcr.io/prizz/opencode-cloud:${{ steps.new.outputs.version }}
      ```
    draft: false
    prerelease: false
```

## Verification

1. **Test workflow dispatch:**
   - Go to Actions tab in GitHub
   - Select "Version Bump" workflow
   - Click "Run workflow"
   - Select bump type and run

2. **Verify version files updated:**
   - Check commit shows all version files changed
   - Verify Cargo.lock also updated

3. **Verify downstream triggers:**
   - Publish workflow triggered by tag
   - Docker Publish workflow triggered by tag

4. **Verify releases created:**
   - crates.io shows new version
   - npm shows new version
   - GHCR shows new Docker image
   - GitHub Release created (if enabled)

## Dependencies

- Plan 14-01 (docker-publish.yml must exist)
- Repository secrets: CARGO_REGISTRY_TOKEN (already configured)

## Outputs

- `.github/workflows/version-bump.yml` - New version bump workflow
- `.github/workflows/publish.yml` - Updated to accept both tag formats
- `.github/workflows/docker-publish.yml` - Updated to accept both tag formats

## Notes

### Two-Tag Strategy

We create both `v*` and `release/v*` tags:
- **v* tags:** Standard semantic versioning tag (e.g., `v1.0.9`)
- **release/v* tags:** Backward compatibility with existing publish.yml trigger

This ensures existing infrastructure continues working while providing cleaner version tags.

### GitHub Actions Bot

Using `github-actions[bot]` for commits ensures:
- Clear audit trail of automated changes
- Doesn't trigger CI loops (GitHub Actions ignores commits from Actions)
- Professional appearance in commit history

### Preventing Tag Conflicts

The workflow checks if the target tag exists before proceeding. This prevents accidental overwrites and ensures version numbers always increment.

### Local Release Script

The existing `scripts/release.sh` remains functional for developers who prefer local releases. The GitHub Actions workflow provides an alternative for those who prefer UI-based releases or need to release from machines without the development environment.

### Future Enhancements

After this plan, consider:
- Automatic changelog generation from conventional commits
- Pre-release/beta version support (e.g., `1.0.9-beta.1`)
- Scheduled releases (weekly patch if changes exist)
