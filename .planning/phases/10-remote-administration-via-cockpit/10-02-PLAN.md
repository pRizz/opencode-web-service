---
phase: 10-remote-administration-via-cockpit
plan: 02
type: execute
wave: 2
depends_on: ["10-01"]
files_modified:
  - packages/core/src/config/schema.rs
  - packages/core/src/docker/container.rs
  - packages/core/src/docker/mod.rs
  - packages/cli-rust/src/commands/start.rs
autonomous: true

must_haves:
  truths:
    - "Config has cockpit_port field (default 9090)"
    - "Config has cockpit_enabled field (default true)"
    - "Container is created with CAP_SYS_ADMIN capability"
    - "Container is created with tmpfs mounts for /run and /tmp"
    - "Container is created with cgroup bind mount"
    - "Cockpit port 9090 in container is mapped to host cockpit_port when enabled"
    - "CLI start command passes cockpit settings through to container creation"
  artifacts:
    - path: "packages/core/src/config/schema.rs"
      provides: "cockpit_port, cockpit_enabled fields"
      contains: "cockpit_port"
    - path: "packages/core/src/docker/container.rs"
      provides: "systemd-compatible container creation"
      contains: "CAP_SYS_ADMIN"
    - path: "packages/core/src/docker/mod.rs"
      provides: "setup_and_start with cockpit parameters"
      contains: "cockpit_port"
    - path: "packages/cli-rust/src/commands/start.rs"
      provides: "start command passing cockpit config"
      contains: "cockpit_port"
  key_links:
    - from: "schema.rs cockpit_enabled"
      to: "container.rs port_bindings"
      via: "Config passed through mod.rs to create_container"
      pattern: "cockpit_port"
    - from: "container.rs cap_add"
      to: "systemd in container"
      via: "CAP_SYS_ADMIN capability"
      pattern: "SYS_ADMIN"
    - from: "start.rs start_container"
      to: "mod.rs setup_and_start"
      via: "config.cockpit_port and config.cockpit_enabled passed as args"
      pattern: "setup_and_start.*cockpit"
---

<objective>
Add Cockpit config fields and update container creation for systemd compatibility

Purpose: Extend the config schema with Cockpit settings and update container creation to add the capabilities and mounts required for systemd to function inside the container. Wire CLI start command to pass cockpit settings through the call chain.

Output: Config schema with cockpit_port/cockpit_enabled, container creation with CAP_SYS_ADMIN and proper mounts, CLI wiring complete
</objective>

<execution_context>
@~/.claude/get-shit-done/workflows/execute-plan.md
@~/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/10-remote-administration-via-cockpit/10-CONTEXT.md
@.planning/phases/10-remote-administration-via-cockpit/10-RESEARCH.md
@packages/core/src/config/schema.rs
@packages/core/src/docker/container.rs
@packages/core/src/docker/mod.rs
@packages/cli-rust/src/commands/start.rs
</context>

<tasks>

<task type="auto">
  <name>Task 1: Add Cockpit fields to config schema</name>
  <files>packages/core/src/config/schema.rs</files>
  <action>
Add cockpit_port and cockpit_enabled fields to the Config struct:

1. Add the fields after the users field:

```rust
/// Cockpit web console port (default: 9090)
#[serde(default = "default_cockpit_port")]
pub cockpit_port: u16,

/// Enable Cockpit web console (default: true)
#[serde(default = "default_cockpit_enabled")]
pub cockpit_enabled: bool,
```

2. Add the default functions:

```rust
fn default_cockpit_port() -> u16 {
    9090
}

fn default_cockpit_enabled() -> bool {
    true
}
```

3. Update the Default impl to include the new fields:

```rust
impl Default for Config {
    fn default() -> Self {
        Self {
            // ... existing fields ...
            users: Vec::new(),
            cockpit_port: default_cockpit_port(),
            cockpit_enabled: default_cockpit_enabled(),
        }
    }
}
```

4. Add tests for the new fields:

```rust
#[test]
fn test_default_config_cockpit_fields() {
    let config = Config::default();
    assert_eq!(config.cockpit_port, 9090);
    assert!(config.cockpit_enabled);
}

#[test]
fn test_serialize_deserialize_with_cockpit_fields() {
    let config = Config {
        cockpit_port: 9091,
        cockpit_enabled: false,
        ..Config::default()
    };
    let json = serde_json::to_string(&config).unwrap();
    let parsed: Config = serde_json::from_str(&json).unwrap();
    assert_eq!(parsed.cockpit_port, 9091);
    assert!(!parsed.cockpit_enabled);
}

#[test]
fn test_cockpit_fields_default_on_missing() {
    // Old configs without cockpit fields should get defaults
    let json = r#"{"version": 1}"#;
    let config: Config = serde_json::from_str(json).unwrap();
    assert_eq!(config.cockpit_port, 9090);
    assert!(config.cockpit_enabled);
}
```
  </action>
  <verify>Run `just test` - all tests pass including new Cockpit field tests</verify>
  <done>Config schema includes cockpit_port (default 9090) and cockpit_enabled (default true)</done>
</task>

<task type="auto">
  <name>Task 2: Update container creation for systemd support</name>
  <files>packages/core/src/docker/container.rs</files>
  <action>
Update create_container function to support systemd inside the container:

1. Update the function signature to accept cockpit settings:

```rust
pub async fn create_container(
    client: &DockerClient,
    name: Option<&str>,
    image: Option<&str>,
    opencode_web_port: Option<u16>,
    env_vars: Option<Vec<String>>,
    bind_address: Option<&str>,
    cockpit_port: Option<u16>,
    cockpit_enabled: Option<bool>,
) -> Result<String, DockerError> {
```

2. Inside the function, get the cockpit settings with defaults:

```rust
let cockpit_port_val = cockpit_port.unwrap_or(9090);
let cockpit_enabled_val = cockpit_enabled.unwrap_or(true);
```

3. Update port bindings to include Cockpit when enabled. IMPORTANT: The container always listens on port 9090, so we map host:cockpit_port_val -> container:9090:

```rust
// Create port bindings (default to localhost for security)
let bind_addr = bind_address.unwrap_or("127.0.0.1");
let mut port_bindings: PortMap = HashMap::new();

// opencode web port
port_bindings.insert(
    "3000/tcp".to_string(),
    Some(vec![PortBinding {
        host_ip: Some(bind_addr.to_string()),
        host_port: Some(port.to_string()),
    }]),
);

// Cockpit port (if enabled)
// Container always listens on 9090, map to host's configured port
if cockpit_enabled_val {
    port_bindings.insert(
        "9090/tcp".to_string(),  // Container port is always 9090
        Some(vec![PortBinding {
            host_ip: Some(bind_addr.to_string()),
            host_port: Some(cockpit_port_val.to_string()),  // Host port from config
        }]),
    );
}
```

4. Update exposed_ports map to include Cockpit (always 9090 inside container):

```rust
let mut exposed_ports = HashMap::new();
exposed_ports.insert("3000/tcp".to_string(), HashMap::new());
if cockpit_enabled_val {
    exposed_ports.insert("9090/tcp".to_string(), HashMap::new());  // Always 9090 in container
}
```

5. Update host_config with systemd requirements. Need to add imports first:

```rust
use std::collections::HashMap;
```

Then update HostConfig:

```rust
// Create host config with systemd support
let host_config = HostConfig {
    mounts: Some(mounts),
    port_bindings: Some(port_bindings),
    auto_remove: Some(false),
    // CAP_SYS_ADMIN required for systemd cgroup access
    cap_add: Some(vec!["SYS_ADMIN".to_string()]),
    // tmpfs for /run and /tmp (required for systemd)
    tmpfs: Some(HashMap::from([
        ("/run".to_string(), "".to_string()),
        ("/tmp".to_string(), "".to_string()),
    ])),
    // cgroup mount (read-only for security)
    binds: Some(vec![
        "/sys/fs/cgroup:/sys/fs/cgroup:ro".to_string(),
    ]),
    ..Default::default()
};
```

Note: The `binds` field is for legacy bind mount syntax. The cgroup mount is separate from the named volume mounts which use the `mounts` field.

6. Add debug logging for Cockpit:

```rust
debug!(
    "Creating container {} from image {} with port {} and cockpit_port {} (enabled: {})",
    container_name, image_name, port, cockpit_port_val, cockpit_enabled_val
);
```
  </action>
  <verify>Run `just test` - all tests pass; code compiles with no warnings</verify>
  <done>Container creation includes CAP_SYS_ADMIN, tmpfs mounts, cgroup bind mount, and Cockpit port mapping (host:config_port -> container:9090)</done>
</task>

<task type="auto">
  <name>Task 3: Update setup_and_start and CLI to pass cockpit settings</name>
  <files>packages/core/src/docker/mod.rs, packages/cli-rust/src/commands/start.rs</files>
  <action>
Update the call chain from CLI -> mod.rs -> container.rs to pass cockpit settings:

**Step 1: Update packages/core/src/docker/mod.rs**

1. Find the setup_and_start function (around line 77) and update its signature:

```rust
/// Full setup: ensure volumes exist, create container if needed, start it
///
/// # Arguments
/// * `client` - Docker client
/// * `opencode_web_port` - Port to bind on host for opencode web UI (defaults to OPENCODE_WEB_PORT)
/// * `env_vars` - Additional environment variables (optional)
/// * `bind_address` - IP address to bind on host (defaults to "127.0.0.1")
/// * `cockpit_port` - Port to bind on host for Cockpit (defaults to 9090)
/// * `cockpit_enabled` - Whether to enable Cockpit port mapping (defaults to true)
pub async fn setup_and_start(
    client: &DockerClient,
    opencode_web_port: Option<u16>,
    env_vars: Option<Vec<String>>,
    bind_address: Option<&str>,
    cockpit_port: Option<u16>,
    cockpit_enabled: Option<bool>,
) -> Result<String, DockerError> {
```

2. Update the create_container call inside setup_and_start (around line 100) to pass the new parameters:

```rust
// Create new container
container::create_container(
    client,
    None,
    None,
    opencode_web_port,
    env_vars,
    bind_address,
    cockpit_port,
    cockpit_enabled,
)
.await?
```

**Step 2: Update packages/cli-rust/src/commands/start.rs**

1. Find the start_container function (around line 270) and update it to pass cockpit settings:

```rust
/// Start the container, returning the container ID or error
async fn start_container(
    client: &DockerClient,
    port: u16,
    bind_address: &str,
    cockpit_port: u16,
    cockpit_enabled: bool,
) -> Result<String, DockerError> {
    setup_and_start(
        client,
        Some(port),
        None,
        Some(bind_address),
        Some(cockpit_port),
        Some(cockpit_enabled),
    )
    .await
}
```

2. Find the call to start_container in cmd_start (around line 150) and update it to pass config values:

```rust
let container_id = match start_container(
    &client,
    port,
    bind_addr,
    config.cockpit_port,
    config.cockpit_enabled,
).await {
```

**Step 3: Update other callers of setup_and_start**

Search for other files that call setup_and_start and update them:

- packages/cli-rust/src/commands/update.rs - if it calls setup_and_start, add None, None for cockpit params (or pass config values if config is loaded)
- packages/cli-rust/src/commands/restart.rs - same treatment

For callers that don't need cockpit customization, pass None for both:

```rust
setup_and_start(client, Some(port), None, Some(bind_address), None, None).await
```

This maintains backward compatibility while allowing explicit cockpit configuration.
  </action>
  <verify>Run `just build` and `just test` - all compilation and tests pass</verify>
  <done>All callers of setup_and_start updated: mod.rs signature updated, start.rs passes config.cockpit_port and config.cockpit_enabled, other callers pass None for defaults</done>
</task>

</tasks>

<verification>
1. Config schema has cockpit_port with default 9090
2. Config schema has cockpit_enabled with default true
3. Old configs without cockpit fields deserialize correctly with defaults
4. Container creation includes CAP_SYS_ADMIN capability
5. Container creation includes tmpfs for /run and /tmp
6. Container creation includes cgroup bind mount
7. Cockpit port mapping: host:config_port -> container:9090 (when enabled)
8. setup_and_start accepts cockpit_port and cockpit_enabled parameters
9. start.rs passes config.cockpit_port and config.cockpit_enabled to setup_and_start
10. All tests pass: `just test`
11. Build succeeds: `just build`
</verification>

<success_criteria>
- Config schema extended with cockpit_port and cockpit_enabled
- Container creation updated for systemd compatibility
- CLI start command passes cockpit settings through entire call chain
- All tests pass
</success_criteria>

<output>
After completion, create `.planning/phases/10-remote-administration-via-cockpit/10-02-SUMMARY.md`
</output>
