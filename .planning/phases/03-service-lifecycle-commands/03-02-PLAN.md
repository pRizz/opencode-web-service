---
phase: 03-service-lifecycle-commands
plan: 02
type: execute
wave: 2
depends_on: ["01"]
files_modified:
  - packages/cli-rust/src/lib.rs
  - packages/cli-rust/src/commands/mod.rs
  - packages/cli-rust/src/commands/status.rs
  - packages/cli-rust/src/commands/logs.rs
  - packages/cli-rust/src/output/mod.rs
  - packages/cli-rust/src/output/colors.rs
autonomous: true

must_haves:
  truths:
    - "User can check status via `occ status` showing state, URL, uptime"
    - "User can view logs via `occ logs` with follow mode by default"
    - "Logs support -n lines, --no-follow, --timestamps, --grep flags"
    - "Status shows colored state (green=running, red=stopped)"
    - "Quiet mode: status exits 0 if running, 1 if stopped; logs outputs raw lines"
  artifacts:
    - path: "packages/cli-rust/src/commands/status.rs"
      provides: "Status command with key-value display"
      min_lines: 80
    - path: "packages/cli-rust/src/commands/logs.rs"
      provides: "Logs command with streaming and filtering"
      min_lines: 100
    - path: "packages/cli-rust/src/output/colors.rs"
      provides: "Color definitions for states and log levels"
      min_lines: 30
  key_links:
    - from: "packages/cli-rust/src/lib.rs"
      to: "commands::status::cmd_status"
      via: "match on Commands::Status"
      pattern: "Commands::Status.*=>.*cmd_status"
    - from: "packages/cli-rust/src/commands/logs.rs"
      to: "bollard::container::LogsOptions"
      via: "log streaming"
      pattern: "LogsOptions|logs\\("
---

<objective>
Implement status and logs CLI commands for service inspection

Purpose: Enables users to check service state and troubleshoot issues by viewing container output. Essential for debugging and monitoring the opencode service.

Output: Two working commands (`occ status`, `occ logs`) with colored output, log streaming with follow mode, and filtering capabilities.
</objective>

<execution_context>
@~/.claude/get-shit-done/workflows/execute-plan.md
@~/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/03-service-lifecycle-commands/03-CONTEXT.md
@.planning/phases/03-service-lifecycle-commands/03-RESEARCH.md
@.planning/phases/02-docker-integration/02-03-SUMMARY.md
@.planning/phases/03-service-lifecycle-commands/03-01-SUMMARY.md

# Key existing files
@packages/cli-rust/src/lib.rs
@packages/core/src/docker/mod.rs
@packages/core/src/docker/container.rs
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create colors module and status command</name>
  <files>
    - packages/cli-rust/src/output/colors.rs
    - packages/cli-rust/src/output/mod.rs
    - packages/cli-rust/src/commands/status.rs
    - packages/cli-rust/src/commands/mod.rs
  </files>
  <action>
1. Create packages/cli-rust/src/output/colors.rs:
   - `state_style(state: &str) -> StyledObject<String>`:
     - "running" -> green bold
     - "stopped", "exited" -> red
     - "starting", "restarting" -> yellow
     - other -> dim
   - `log_level_style(line: &str) -> StyledObject<&str>`:
     - Contains "ERROR" or "error" -> red
     - Contains "WARN" or "warn" -> yellow
     - Contains "INFO" or "info" -> cyan
     - Contains "DEBUG" or "debug" -> dim
     - else -> unstyled

2. Update packages/cli-rust/src/output/mod.rs (created by Plan 03-01):
   - Add `pub mod colors;`
   - Re-export color functions

3. Create packages/cli-rust/src/commands/status.rs:
   - `StatusArgs` struct (empty for now)
   - `cmd_status(args: &StatusArgs, quiet: bool, verbose: u8)` async function:
     a. Connect to Docker
     b. Check if container exists - if not, print "No service found. Run 'occ start' first." and return Ok(())
     c. Get container info via `client.inner().inspect_container(CONTAINER_NAME, None)`
     d. Extract from ContainerInspectResponse:
        - state: `info.state.and_then(|s| s.status).map(|s| s.to_string())`
        - running: `info.state.and_then(|s| s.running).unwrap_or(false)`
        - started_at: `info.state.and_then(|s| s.started_at)` (Option<String>)
        - finished_at: `info.state.and_then(|s| s.finished_at)` (Option<String>)
        - health: `info.state.and_then(|s| s.health).and_then(|h| h.status).map(|s| s.to_string())`
        - container_id: `info.id` (first 12 chars)
        - image: `info.config.and_then(|c| c.image)`
        - port: Extract from info.network_settings.ports (get host port for 3000/tcp)
     e. Quiet mode behavior:
        - If running: exit 0 with no output
        - If not running: exit with code 1 (use std::process::exit(1))
     f. Normal mode - print key-value format:
        ```
        State:       {colored_state}
        URL:         http://localhost:{port}      # only if running
        Container:   {name} ({id_short})
        Image:       {image}
        Uptime:      {duration} (since {timestamp})  # only if running
        Port:        {host_port} -> container:3000   # only if running
        Health:      {health_status}                 # only if available
        Config:      {config_path}

        # If stopped:
        Last run:    {finished_at}

        Run 'occ start' to start the service
        ```
     g. Use `humantime::format_duration()` for uptime (calculate from started_at)
     h. Parse started_at/finished_at from ISO8601 string to DateTime (use chrono if needed, or simple string formatting)
   - Get config path from `opencode_cloud_core::config::paths::get_config_path()`

4. Update packages/cli-rust/src/commands/mod.rs (created by Plan 03-01):
   - Add `pub mod status;`
   - Re-export: `cmd_status`, `StatusArgs`
  </action>
  <verify>
    - `cargo check -p opencode-cloud` passes
    - `cargo test -p opencode-cloud` passes
  </verify>
  <done>Status command shows service state with colored output and key-value format</done>
</task>

<task type="auto">
  <name>Task 2: Implement logs command with streaming and filtering</name>
  <files>
    - packages/cli-rust/src/commands/logs.rs
    - packages/cli-rust/src/commands/mod.rs
  </files>
  <action>
1. Create packages/cli-rust/src/commands/logs.rs:
   - `LogsArgs` struct with clap derive:
     - `-n` / `--lines`: String, default "50" (number of lines to show)
     - `--no-follow`: bool flag, don't follow (one-shot dump)
     - `--timestamps`: bool flag, prefix with timestamps
     - `--grep`: Option<String>, filter lines containing pattern
   - `cmd_logs(args: &LogsArgs, quiet: bool)` async function:
     a. Connect to Docker
     b. Check if container exists - if not, print "No container found. Run 'occ start' first." and return error
     c. Determine follow mode: `!args.no_follow`
     d. If not quiet and follow mode, print dim message: "Following logs (Ctrl+C to exit)..."
     e. Create LogsOptions:
        ```rust
        let options = LogsOptions::<String> {
            stdout: true,
            stderr: true,
            follow,
            tail: args.lines.clone(),
            timestamps: args.timestamps,
            ..Default::default()
        };
        ```
     f. Get log stream: `client.inner().logs(CONTAINER_NAME, Some(options))`
     g. Stream processing loop using `futures_util::StreamExt`:
        ```rust
        while let Some(result) = stream.next().await {
            match result {
                Ok(output) => {
                    let line = match output {
                        LogOutput::StdOut { message } |
                        LogOutput::StdErr { message } => {
                            String::from_utf8_lossy(&message).to_string()
                        }
                        _ => continue,
                    };

                    // Apply grep filter
                    if let Some(ref pattern) = args.grep {
                        if !line.contains(pattern) {
                            continue;
                        }
                    }

                    // Print with color coding (unless quiet)
                    if quiet {
                        print!("{}", line);
                    } else if console::colors_enabled() {
                        print!("{}", log_level_style(&line));
                    } else {
                        print!("{}", line);
                    }
                }
                Err(_) => {
                    // Check if container stopped
                    if follow {
                        if !container_is_running(client, CONTAINER_NAME).await.unwrap_or(false) {
                            if !quiet {
                                eprintln!("\nContainer stopped");
                            }
                        }
                    }
                    break;
                }
            }
        }
        ```
     h. Import LogOutput from bollard::container
     i. Handle Ctrl+C gracefully (stream will end naturally)

2. Update packages/cli-rust/src/commands/mod.rs:
   - Add `pub mod logs;`
   - Re-export: `cmd_logs`, `LogsArgs`

Note: The log lines from Docker may or may not include newlines. Check if line ends with newline before printing, add one if missing.
  </action>
  <verify>
    - `cargo check -p opencode-cloud` passes
    - `cargo test -p opencode-cloud` passes
  </verify>
  <done>Logs command streams container output with follow, filtering, and color coding</done>
</task>

<task type="auto">
  <name>Task 3: Wire status and logs into CLI</name>
  <files>
    - packages/cli-rust/src/lib.rs
  </files>
  <action>
1. Update packages/cli-rust/src/lib.rs:
   - Add to Commands enum:
     ```rust
     /// Show service status
     Status(commands::StatusArgs),
     /// View service logs
     Logs(commands::LogsArgs),
     ```
   - Update match in run() to handle new commands:
     ```rust
     Some(Commands::Status(args)) => {
         let rt = tokio::runtime::Runtime::new()?;
         rt.block_on(commands::cmd_status(&args, cli.quiet, cli.verbose))
     }
     Some(Commands::Logs(args)) => {
         let rt = tokio::runtime::Runtime::new()?;
         rt.block_on(commands::cmd_logs(&args, cli.quiet))
     }
     ```

2. Test CLI help output:
   - `cargo run -p opencode-cloud -- --help` should show status, logs commands
   - `cargo run -p opencode-cloud -- status --help` should show status help
   - `cargo run -p opencode-cloud -- logs --help` should show -n, --no-follow, --timestamps, --grep flags

3. Run full verification suite.
  </action>
  <verify>
    - `just fmt && just lint && just test && just build` all pass
    - `cargo run -p opencode-cloud -- --help` shows Status, Logs commands
    - `cargo run -p opencode-cloud -- status --help` works
    - `cargo run -p opencode-cloud -- logs --help` shows all flags
  </verify>
  <done>Status and logs commands are wired into CLI and accessible via --help</done>
</task>

</tasks>

<verification>
Phase verification (run after all tasks):
1. `just fmt && just lint && just test && just build` - all pass
2. `cargo run -p opencode-cloud -- --help` - shows status, logs commands
3. `cargo run -p opencode-cloud -- status --help` - shows status command help
4. `cargo run -p opencode-cloud -- logs --help` - shows -n, --no-follow, --timestamps, --grep flags
</verification>

<success_criteria>
- Status command shows service state with colored output
- Status shows key-value format: State, URL, Container, Image, Uptime, Port, Health, Config
- Status quiet mode: exits 0 if running, 1 if stopped
- Logs command follows by default (last 50 lines)
- Logs supports -n/--lines, --no-follow, --timestamps, --grep flags
- Logs color-codes by log level (ERROR=red, WARN=yellow, INFO=cyan, DEBUG=dim)
- Logs quiet mode outputs raw lines without status messages
- All pre-commit checks pass (fmt, lint, test, build)
</success_criteria>

<output>
After completion, create `.planning/phases/03-service-lifecycle-commands/03-02-SUMMARY.md`
</output>
