---
phase: 11-remote-host-management
plan: 02
type: execute
wave: 2
depends_on: ["11-01"]
files_modified:
  - packages/cli-rust/src/commands/host/mod.rs
  - packages/cli-rust/src/commands/host/add.rs
  - packages/cli-rust/src/commands/host/remove.rs
  - packages/cli-rust/src/commands/host/list.rs
  - packages/cli-rust/src/commands/host/show.rs
  - packages/cli-rust/src/commands/host/edit.rs
  - packages/cli-rust/src/commands/host/test.rs
  - packages/cli-rust/src/commands/host/default.rs
  - packages/cli-rust/src/commands/mod.rs
  - packages/cli-rust/src/lib.rs
autonomous: true

must_haves:
  truths:
    - "User can add a host with occ host add <name> <hostname>"
    - "User can remove a host with occ host remove <name>"
    - "User can list hosts with occ host list"
    - "User can show host details with occ host show <name>"
    - "User can edit host config with occ host edit <name>"
    - "User can test host connection with occ host test <name>"
    - "User can set/clear default host with occ host default"
    - "Host add validates SSH connection by default"
    - "Host add supports --no-verify to skip connection test"
  artifacts:
    - path: "packages/cli-rust/src/commands/host/mod.rs"
      provides: "Host subcommand routing"
      contains: "HostCommands"
    - path: "packages/cli-rust/src/commands/host/add.rs"
      provides: "occ host add implementation"
      contains: "cmd_host_add"
    - path: "packages/cli-rust/src/commands/host/list.rs"
      provides: "occ host list implementation"
      contains: "cmd_host_list"
    - path: "packages/cli-rust/src/commands/host/test.rs"
      provides: "occ host test implementation"
      contains: "cmd_host_test"
  key_links:
    - from: "lib.rs Commands::Host"
      to: "host/mod.rs cmd_host"
      via: "Subcommand dispatch"
      pattern: "Commands::Host"
    - from: "host/add.rs"
      to: "core::save_hosts"
      via: "Persist new host to hosts.json"
      pattern: "save_hosts"
    - from: "host/test.rs"
      to: "core::test_connection"
      via: "SSH connection test"
      pattern: "test_connection"
---

<objective>
Implement all occ host subcommands for host CRUD operations

Purpose: Provide CLI commands for users to manage remote hosts: add new hosts with SSH configuration, list/show existing hosts, edit configurations, test connections, and set the default host.

Output: Complete `occ host` command tree with add, remove, list, show, edit, test, and default subcommands
</objective>

<execution_context>
@~/.claude/get-shit-done/workflows/execute-plan.md
@~/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/11-remote-host-management/11-CONTEXT.md
@.planning/phases/11-remote-host-management/11-RESEARCH.md
@.planning/phases/11-remote-host-management/11-01-SUMMARY.md
@packages/cli-rust/src/commands/user/mod.rs
@packages/cli-rust/src/commands/mod.rs
@packages/cli-rust/src/lib.rs
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create host subcommand structure and add/remove commands</name>
  <files>packages/cli-rust/src/commands/host/mod.rs, packages/cli-rust/src/commands/host/add.rs, packages/cli-rust/src/commands/host/remove.rs</files>
  <action>
Create the host command module structure following the pattern from user commands:

**1. Create packages/cli-rust/src/commands/host/mod.rs:**

```rust
//! Host management subcommand implementations
//!
//! Provides `occ host` subcommands for managing remote Docker hosts.

mod add;
mod default;
mod edit;
mod list;
mod remove;
mod show;
mod test;

use anyhow::Result;
use clap::{Args, Subcommand};

pub use add::cmd_host_add;
pub use default::cmd_host_default;
pub use edit::cmd_host_edit;
pub use list::cmd_host_list;
pub use remove::cmd_host_remove;
pub use show::cmd_host_show;
pub use test::cmd_host_test;

/// Host management command arguments
#[derive(Args)]
pub struct HostArgs {
    #[command(subcommand)]
    pub command: HostCommands,
}

/// Host management subcommands
#[derive(Subcommand)]
pub enum HostCommands {
    /// Add a new remote host
    Add(add::HostAddArgs),
    /// Remove a remote host
    Remove(remove::HostRemoveArgs),
    /// List all configured hosts
    List(list::HostListArgs),
    /// Show details for a host
    Show(show::HostShowArgs),
    /// Edit host configuration
    Edit(edit::HostEditArgs),
    /// Test connection to a host
    Test(test::HostTestArgs),
    /// Set or show the default host
    Default(default::HostDefaultArgs),
}

/// Handle host command
///
/// Routes to the appropriate handler based on the subcommand.
pub async fn cmd_host(args: &HostArgs, quiet: bool, verbose: u8) -> Result<()> {
    match &args.command {
        HostCommands::Add(add_args) => cmd_host_add(add_args, quiet, verbose).await,
        HostCommands::Remove(remove_args) => cmd_host_remove(remove_args, quiet, verbose).await,
        HostCommands::List(list_args) => cmd_host_list(list_args, quiet, verbose).await,
        HostCommands::Show(show_args) => cmd_host_show(show_args, quiet, verbose).await,
        HostCommands::Edit(edit_args) => cmd_host_edit(edit_args, quiet, verbose).await,
        HostCommands::Test(test_args) => cmd_host_test(test_args, quiet, verbose).await,
        HostCommands::Default(default_args) => cmd_host_default(default_args, quiet, verbose).await,
    }
}
```

**2. Create packages/cli-rust/src/commands/host/add.rs:**

```rust
//! occ host add - Add a new remote host

use anyhow::{Result, bail};
use clap::Args;
use console::style;
use indicatif::{ProgressBar, ProgressStyle};
use opencode_cloud_core::{
    HostConfig, load_hosts, save_hosts, test_connection,
};

/// Arguments for host add command
#[derive(Args)]
pub struct HostAddArgs {
    /// Name to identify this host (e.g., "prod-1", "staging")
    pub name: String,

    /// SSH hostname or IP address
    pub hostname: String,

    /// SSH username (default: current user)
    #[arg(short, long)]
    pub user: Option<String>,

    /// SSH port (default: 22)
    #[arg(short, long)]
    pub port: Option<u16>,

    /// Path to SSH identity file (private key)
    #[arg(short, long)]
    pub identity_file: Option<String>,

    /// Jump host for ProxyJump (user@host:port format)
    #[arg(short = 'J', long)]
    pub jump_host: Option<String>,

    /// Group/tag for organization (can be specified multiple times)
    #[arg(short, long)]
    pub group: Vec<String>,

    /// Description for this host
    #[arg(short, long)]
    pub description: Option<String>,

    /// Skip connection verification
    #[arg(long)]
    pub no_verify: bool,

    /// Overwrite if host already exists
    #[arg(long)]
    pub force: bool,
}

pub async fn cmd_host_add(args: &HostAddArgs, quiet: bool, _verbose: u8) -> Result<()> {
    // Load existing hosts
    let mut hosts = load_hosts()?;

    // Check if host already exists
    if hosts.has_host(&args.name) && !args.force {
        bail!(
            "Host '{}' already exists. Use --force to overwrite, or choose a different name.",
            args.name
        );
    }

    // Build host config
    let mut config = HostConfig::new(&args.hostname);

    if let Some(user) = &args.user {
        config = config.with_user(user);
    }
    if let Some(port) = args.port {
        config = config.with_port(port);
    }
    if let Some(key) = &args.identity_file {
        config = config.with_identity_file(key);
    }
    if let Some(jump) = &args.jump_host {
        config = config.with_jump_host(jump);
    }
    for group in &args.group {
        config = config.with_group(group);
    }
    if let Some(desc) = &args.description {
        config = config.with_description(desc);
    }

    // Test connection unless --no-verify
    if !args.no_verify {
        if !quiet {
            let spinner = ProgressBar::new_spinner();
            spinner.set_style(
                ProgressStyle::default_spinner()
                    .template("{spinner:.cyan} {msg}")
                    .expect("valid template"),
            );
            spinner.set_message(format!("Testing connection to {}...", args.hostname));
            spinner.enable_steady_tick(std::time::Duration::from_millis(100));

            match test_connection(&config).await {
                Ok(docker_version) => {
                    spinner.finish_with_message(format!(
                        "{} Connected (Docker {})",
                        style("✓").green(),
                        docker_version
                    ));
                }
                Err(e) => {
                    spinner.finish_with_message(format!("{} Connection failed", style("✗").red()));
                    eprintln!();
                    eprintln!("  {}", e);
                    eprintln!();
                    eprintln!(
                        "  {} Use {} to add the host anyway.",
                        style("Tip:").cyan(),
                        style("--no-verify").yellow()
                    );
                    bail!("Connection verification failed");
                }
            }
        } else {
            // Quiet mode - just test, fail silently
            test_connection(&config).await?;
        }
    }

    // Add host to config
    let is_overwrite = hosts.has_host(&args.name);
    hosts.add_host(&args.name, config);

    // Save
    save_hosts(&hosts)?;

    if !quiet {
        if is_overwrite {
            println!(
                "{} Host '{}' updated ({}).",
                style("Updated:").yellow(),
                style(&args.name).cyan(),
                args.hostname
            );
        } else {
            println!(
                "{} Host '{}' added ({}).",
                style("Added:").green(),
                style(&args.name).cyan(),
                args.hostname
            );
        }

        if args.no_verify {
            println!(
                "  {} Connection not verified. Run {} to test.",
                style("Note:").dim(),
                style(format!("occ host test {}", args.name)).yellow()
            );
        }
    }

    Ok(())
}
```

**3. Create packages/cli-rust/src/commands/host/remove.rs:**

```rust
//! occ host remove - Remove a remote host

use anyhow::{Result, bail};
use clap::Args;
use console::style;
use dialoguer::Confirm;
use opencode_cloud_core::{load_hosts, save_hosts};

/// Arguments for host remove command
#[derive(Args)]
pub struct HostRemoveArgs {
    /// Name of the host to remove
    pub name: String,

    /// Skip confirmation prompt
    #[arg(short, long)]
    pub force: bool,
}

pub async fn cmd_host_remove(args: &HostRemoveArgs, quiet: bool, _verbose: u8) -> Result<()> {
    // Load existing hosts
    let mut hosts = load_hosts()?;

    // Check if host exists
    if !hosts.has_host(&args.name) {
        bail!("Host '{}' not found.", args.name);
    }

    // Confirm unless --force
    if !args.force && !quiet {
        let is_default = hosts.default_host.as_deref() == Some(&args.name);
        let prompt = if is_default {
            format!(
                "Remove host '{}' (currently the default)?",
                style(&args.name).cyan()
            )
        } else {
            format!("Remove host '{}'?", style(&args.name).cyan())
        };

        let confirmed = Confirm::new()
            .with_prompt(prompt)
            .default(false)
            .interact()?;

        if !confirmed {
            println!("Cancelled.");
            return Ok(());
        }
    }

    // Remove host
    hosts.remove_host(&args.name);

    // Save
    save_hosts(&hosts)?;

    if !quiet {
        println!(
            "{} Host '{}' removed.",
            style("Removed:").yellow(),
            style(&args.name).cyan()
        );
    }

    Ok(())
}
```
  </action>
  <verify>Run `just build` - compilation succeeds (commands not yet wired to CLI)</verify>
  <done>Host module structure created with add and remove commands</done>
</task>

<task type="auto">
  <name>Task 2: Create list, show, edit, and test commands</name>
  <files>packages/cli-rust/src/commands/host/list.rs, packages/cli-rust/src/commands/host/show.rs, packages/cli-rust/src/commands/host/edit.rs, packages/cli-rust/src/commands/host/test.rs</files>
  <action>
Create the remaining query and utility commands:

**1. Create packages/cli-rust/src/commands/host/list.rs:**

```rust
//! occ host list - List all configured hosts

use anyhow::Result;
use clap::Args;
use comfy_table::{Cell, Color, Table};
use console::style;
use opencode_cloud_core::load_hosts;

/// Arguments for host list command
#[derive(Args)]
pub struct HostListArgs {
    /// Filter by group
    #[arg(short, long)]
    pub group: Option<String>,

    /// Show only host names (for scripting)
    #[arg(long)]
    pub names_only: bool,
}

pub async fn cmd_host_list(args: &HostListArgs, quiet: bool, _verbose: u8) -> Result<()> {
    let hosts = load_hosts()?;

    if hosts.hosts.is_empty() {
        if !quiet && !args.names_only {
            println!("No hosts configured.");
            println!();
            println!(
                "  {} {}",
                style("Add one with:").dim(),
                style("occ host add <name> <hostname>").yellow()
            );
        }
        return Ok(());
    }

    // Filter by group if specified
    let filtered: Vec<_> = hosts
        .hosts
        .iter()
        .filter(|(_, config)| {
            args.group
                .as_ref()
                .map(|g| config.groups.contains(g))
                .unwrap_or(true)
        })
        .collect();

    if filtered.is_empty() {
        if !quiet && !args.names_only {
            println!(
                "No hosts found in group '{}'.",
                args.group.as_deref().unwrap_or("")
            );
        }
        return Ok(());
    }

    // Names only mode (for scripting)
    if args.names_only || quiet {
        for (name, _) in &filtered {
            println!("{}", name);
        }
        return Ok(());
    }

    // Build table
    let mut table = Table::new();
    table.set_header(vec!["Name", "Hostname", "User", "Port", "Groups", "Default"]);

    for (name, config) in filtered {
        let is_default = hosts.default_host.as_deref() == Some(name.as_str());

        let name_cell = if is_default {
            Cell::new(name).fg(Color::Cyan)
        } else {
            Cell::new(name)
        };

        let port_str = config.port.map(|p| p.to_string()).unwrap_or_else(|| "22".to_string());
        let groups_str = if config.groups.is_empty() {
            "-".to_string()
        } else {
            config.groups.join(", ")
        };
        let default_str = if is_default { "*" } else { "" };

        table.add_row(vec![
            name_cell,
            Cell::new(&config.hostname),
            Cell::new(&config.user),
            Cell::new(port_str),
            Cell::new(groups_str),
            Cell::new(default_str),
        ]);
    }

    println!("{table}");

    if let Some(default) = &hosts.default_host {
        println!();
        println!("  {} {}", style("Default host:").dim(), style(default).cyan());
    }

    Ok(())
}
```

**2. Create packages/cli-rust/src/commands/host/show.rs:**

```rust
//! occ host show - Show details for a host

use anyhow::{Result, bail};
use clap::Args;
use console::style;
use opencode_cloud_core::load_hosts;

/// Arguments for host show command
#[derive(Args)]
pub struct HostShowArgs {
    /// Name of the host to show
    pub name: String,

    /// Output as JSON
    #[arg(long)]
    pub json: bool,
}

pub async fn cmd_host_show(args: &HostShowArgs, quiet: bool, _verbose: u8) -> Result<()> {
    let hosts = load_hosts()?;

    let config = hosts
        .get_host(&args.name)
        .ok_or_else(|| anyhow::anyhow!("Host '{}' not found.", args.name))?;

    if args.json || quiet {
        // JSON output
        let json = serde_json::to_string_pretty(config)?;
        println!("{}", json);
        return Ok(());
    }

    // Pretty output
    let is_default = hosts.default_host.as_deref() == Some(&args.name);

    println!("{}", style(&args.name).cyan().bold());
    if is_default {
        println!("  {} (default)", style("*").green());
    }
    println!();

    println!("  {:<15} {}", style("Hostname:").dim(), config.hostname);
    println!("  {:<15} {}", style("User:").dim(), config.user);
    println!(
        "  {:<15} {}",
        style("Port:").dim(),
        config.port.map(|p| p.to_string()).unwrap_or_else(|| "22 (default)".to_string())
    );

    if let Some(key) = &config.identity_file {
        println!("  {:<15} {}", style("Identity:").dim(), key);
    }

    if let Some(jump) = &config.jump_host {
        println!("  {:<15} {}", style("Jump host:").dim(), jump);
    }

    if !config.groups.is_empty() {
        println!("  {:<15} {}", style("Groups:").dim(), config.groups.join(", "));
    }

    if let Some(desc) = &config.description {
        println!("  {:<15} {}", style("Description:").dim(), desc);
    }

    println!();
    println!(
        "  {} {}",
        style("Test connection:").dim(),
        style(format!("occ host test {}", args.name)).yellow()
    );

    Ok(())
}
```

**3. Create packages/cli-rust/src/commands/host/edit.rs:**

```rust
//! occ host edit - Edit host configuration

use anyhow::{Result, bail};
use clap::Args;
use console::style;
use opencode_cloud_core::{load_hosts, save_hosts};

/// Arguments for host edit command
#[derive(Args)]
pub struct HostEditArgs {
    /// Name of the host to edit
    pub name: String,

    /// New hostname
    #[arg(long)]
    pub hostname: Option<String>,

    /// New SSH username
    #[arg(short, long)]
    pub user: Option<String>,

    /// New SSH port
    #[arg(short, long)]
    pub port: Option<u16>,

    /// New identity file path
    #[arg(short, long)]
    pub identity_file: Option<String>,

    /// New jump host (use empty string to clear)
    #[arg(short = 'J', long)]
    pub jump_host: Option<String>,

    /// Add a group
    #[arg(long)]
    pub add_group: Vec<String>,

    /// Remove a group
    #[arg(long)]
    pub remove_group: Vec<String>,

    /// New description (use empty string to clear)
    #[arg(short, long)]
    pub description: Option<String>,
}

pub async fn cmd_host_edit(args: &HostEditArgs, quiet: bool, _verbose: u8) -> Result<()> {
    let mut hosts = load_hosts()?;

    let config = hosts
        .get_host_mut(&args.name)
        .ok_or_else(|| anyhow::anyhow!("Host '{}' not found.", args.name))?;

    let mut changed = false;

    // Apply changes
    if let Some(hostname) = &args.hostname {
        config.hostname = hostname.clone();
        changed = true;
    }

    if let Some(user) = &args.user {
        config.user = user.clone();
        changed = true;
    }

    if let Some(port) = args.port {
        config.port = Some(port);
        changed = true;
    }

    if let Some(key) = &args.identity_file {
        config.identity_file = if key.is_empty() { None } else { Some(key.clone()) };
        changed = true;
    }

    if let Some(jump) = &args.jump_host {
        config.jump_host = if jump.is_empty() { None } else { Some(jump.clone()) };
        changed = true;
    }

    for group in &args.add_group {
        if !config.groups.contains(group) {
            config.groups.push(group.clone());
            changed = true;
        }
    }

    for group in &args.remove_group {
        if let Some(pos) = config.groups.iter().position(|g| g == group) {
            config.groups.remove(pos);
            changed = true;
        }
    }

    if let Some(desc) = &args.description {
        config.description = if desc.is_empty() { None } else { Some(desc.clone()) };
        changed = true;
    }

    if !changed {
        if !quiet {
            println!("No changes specified. Use --help to see available options.");
        }
        return Ok(());
    }

    // Save
    save_hosts(&hosts)?;

    if !quiet {
        println!(
            "{} Host '{}' updated.",
            style("Updated:").green(),
            style(&args.name).cyan()
        );
        println!(
            "  {} {}",
            style("View changes:").dim(),
            style(format!("occ host show {}", args.name)).yellow()
        );
    }

    Ok(())
}
```

**4. Create packages/cli-rust/src/commands/host/test.rs:**

```rust
//! occ host test - Test connection to a host

use anyhow::{Result, bail};
use clap::Args;
use console::style;
use indicatif::{ProgressBar, ProgressStyle};
use opencode_cloud_core::{load_hosts, test_connection};
use std::time::Duration;

/// Arguments for host test command
#[derive(Args)]
pub struct HostTestArgs {
    /// Name of the host to test
    pub name: String,
}

pub async fn cmd_host_test(args: &HostTestArgs, quiet: bool, _verbose: u8) -> Result<()> {
    let hosts = load_hosts()?;

    let config = hosts
        .get_host(&args.name)
        .ok_or_else(|| anyhow::anyhow!("Host '{}' not found.", args.name))?;

    if quiet {
        // Quiet mode: exit 0 on success, 1 on failure
        match test_connection(config).await {
            Ok(_) => return Ok(()),
            Err(_) => std::process::exit(1),
        }
    }

    let spinner = ProgressBar::new_spinner();
    spinner.set_style(
        ProgressStyle::default_spinner()
            .template("{spinner:.cyan} {msg}")
            .expect("valid template"),
    );
    spinner.set_message(format!(
        "Testing connection to {} ({}@{})...",
        style(&args.name).cyan(),
        config.user,
        config.hostname
    ));
    spinner.enable_steady_tick(Duration::from_millis(100));

    match test_connection(config).await {
        Ok(docker_version) => {
            spinner.finish_with_message(format!(
                "{} Connection successful",
                style("✓").green().bold()
            ));
            println!();
            println!("  {:<15} {}", style("Host:").dim(), args.name);
            println!("  {:<15} {}@{}", style("SSH:").dim(), config.user, config.hostname);
            println!("  {:<15} {}", style("Docker:").dim(), docker_version);
            Ok(())
        }
        Err(e) => {
            spinner.finish_with_message(format!(
                "{} Connection failed",
                style("✗").red().bold()
            ));
            println!();
            println!("  {}", e);
            println!();

            // Provide troubleshooting hints
            println!("{}", style("Troubleshooting:").yellow());
            println!("  1. Verify SSH access: ssh {}@{}", config.user, config.hostname);
            println!("  2. Check Docker is running: ssh {}@{} docker info", config.user, config.hostname);
            if config.identity_file.is_some() {
                println!("  3. Ensure key is loaded: ssh-add {}", config.identity_file.as_ref().unwrap());
            } else {
                println!("  3. Ensure key is loaded: ssh-add");
            }

            bail!("Connection test failed");
        }
    }
}
```
  </action>
  <verify>Run `just build` - compilation succeeds</verify>
  <done>List, show, edit, and test commands implemented</done>
</task>

<task type="auto">
  <name>Task 3: Create default command and wire to CLI</name>
  <files>packages/cli-rust/src/commands/host/default.rs, packages/cli-rust/src/commands/mod.rs, packages/cli-rust/src/lib.rs</files>
  <action>
Create the default command and wire host commands into the CLI:

**1. Create packages/cli-rust/src/commands/host/default.rs:**

```rust
//! occ host default - Set or show the default host

use anyhow::{Result, bail};
use clap::Args;
use console::style;
use opencode_cloud_core::{load_hosts, save_hosts};

/// Arguments for host default command
#[derive(Args)]
pub struct HostDefaultArgs {
    /// Name of the host to set as default (omit to show current, "local" to clear)
    pub name: Option<String>,
}

pub async fn cmd_host_default(args: &HostDefaultArgs, quiet: bool, _verbose: u8) -> Result<()> {
    let mut hosts = load_hosts()?;

    match &args.name {
        None => {
            // Show current default
            match &hosts.default_host {
                Some(name) => {
                    if quiet {
                        println!("{}", name);
                    } else {
                        println!("Default host: {}", style(name).cyan());
                    }
                }
                None => {
                    if quiet {
                        println!("local");
                    } else {
                        println!("Default host: {} (local Docker)", style("local").cyan());
                    }
                }
            }
            Ok(())
        }
        Some(name) if name == "local" || name == "none" || name.is_empty() => {
            // Clear default
            if hosts.default_host.is_none() {
                if !quiet {
                    println!("Default is already local Docker.");
                }
                return Ok(());
            }

            hosts.set_default(None);
            save_hosts(&hosts)?;

            if !quiet {
                println!(
                    "{} Default cleared. Commands will use local Docker.",
                    style("Updated:").green()
                );
            }
            Ok(())
        }
        Some(name) => {
            // Set default
            if !hosts.has_host(name) {
                bail!(
                    "Host '{}' not found. Add it first with: occ host add {} <hostname>",
                    name,
                    name
                );
            }

            hosts.set_default(Some(name.clone()));
            save_hosts(&hosts)?;

            if !quiet {
                println!(
                    "{} Default host set to '{}'.",
                    style("Updated:").green(),
                    style(name).cyan()
                );
                println!(
                    "  {} Commands will now target {} unless {} is specified.",
                    style("Note:").dim(),
                    style(name).cyan(),
                    style("--host").yellow()
                );
            }
            Ok(())
        }
    }
}
```

**2. Update packages/cli-rust/src/commands/mod.rs:**

Add the host module to the existing module list and exports:

```rust
//! CLI command implementations
//!
//! This module contains the implementations for service lifecycle commands.

mod cockpit;
mod config;
mod host;
mod install;
mod logs;
mod restart;
mod setup;
mod start;
mod status;
mod stop;
mod uninstall;
mod update;
mod user;

pub use cockpit::{CockpitArgs, cmd_cockpit};
pub use config::{ConfigArgs, cmd_config};
pub use host::{HostArgs, cmd_host};
pub use install::{InstallArgs, cmd_install};
pub use logs::{LogsArgs, cmd_logs};
pub use restart::{RestartArgs, cmd_restart};
pub use setup::{SetupArgs, cmd_setup};
pub use start::{StartArgs, cmd_start};
pub use status::{StatusArgs, cmd_status};
pub use stop::{StopArgs, cmd_stop};
pub use uninstall::{UninstallArgs, cmd_uninstall};
pub use update::{UpdateArgs, cmd_update};
pub use user::{UserArgs, cmd_user};
```

**3. Update packages/cli-rust/src/lib.rs:**

Add the Host command variant to the Commands enum and handle it in the match:

In the Commands enum (after the existing Cockpit variant):

```rust
    /// Manage remote hosts
    Host(commands::HostArgs),
```

In the match statement in run() (after the Cockpit handler):

```rust
        Some(Commands::Host(args)) => {
            let rt = tokio::runtime::Runtime::new()?;
            rt.block_on(commands::cmd_host(&args, cli.quiet, cli.verbose))
        }
```

The full Commands enum should look like:

```rust
#[derive(Subcommand)]
enum Commands {
    /// Start the opencode service
    Start(commands::StartArgs),
    /// Stop the opencode service
    Stop(commands::StopArgs),
    /// Restart the opencode service
    Restart(commands::RestartArgs),
    /// Show service status
    Status(commands::StatusArgs),
    /// View service logs
    Logs(commands::LogsArgs),
    /// Register service to start on boot/login
    Install(commands::InstallArgs),
    /// Remove service registration
    Uninstall(commands::UninstallArgs),
    /// Manage configuration
    Config(commands::ConfigArgs),
    /// Run interactive setup wizard
    Setup(commands::SetupArgs),
    /// Manage container users
    User(commands::UserArgs),
    /// Update to the latest version or rollback
    Update(commands::UpdateArgs),
    /// Open Cockpit web console
    Cockpit(commands::CockpitArgs),
    /// Manage remote hosts
    Host(commands::HostArgs),
}
```
  </action>
  <verify>Run `just build && just test` - all tests pass, `occ host --help` shows subcommands</verify>
  <done>Host commands fully wired into CLI with all subcommands functional</done>
</task>

</tasks>

<verification>
1. `occ host --help` shows all subcommands (add, remove, list, show, edit, test, default)
2. `occ host add test-host example.com --no-verify` creates entry in hosts.json
3. `occ host list` shows the added host in a table
4. `occ host show test-host` displays all configuration fields
5. `occ host edit test-host --port 2222` updates the port
6. `occ host default test-host` sets the default host
7. `occ host default` shows current default
8. `occ host default local` clears the default
9. `occ host remove test-host --force` removes the host
10. hosts.json is created at ~/.config/opencode-cloud/hosts.json
11. `just build` succeeds with no warnings
12. `just test` passes all tests
</verification>

<success_criteria>
- All 7 host subcommands implemented and functional
- Commands follow existing CLI patterns (quiet mode, verbose, colored output)
- Host add verifies connection by default with --no-verify escape hatch
- Host remove has confirmation prompt with --force escape hatch
- Host list supports --group filter and --names-only for scripting
- Host show supports --json output
- Host edit supports partial updates
- Host default can set, show, and clear default
</success_criteria>

<output>
After completion, create `.planning/phases/11-remote-host-management/11-02-SUMMARY.md`
</output>
