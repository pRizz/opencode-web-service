---
phase: 11-remote-host-management
plan: 01
type: execute
wave: 1
depends_on: []
files_modified:
  - packages/core/src/host/mod.rs
  - packages/core/src/host/schema.rs
  - packages/core/src/host/storage.rs
  - packages/core/src/host/tunnel.rs
  - packages/core/src/host/error.rs
  - packages/core/src/config/paths.rs
  - packages/core/src/lib.rs
autonomous: true

must_haves:
  truths:
    - "Host configuration can be serialized/deserialized to/from hosts.json"
    - "SSH tunnel can be established to a remote host"
    - "hosts.json is stored at ~/.config/opencode-cloud/hosts.json"
    - "SSH tunnel uses system ssh command with BatchMode=yes"
    - "Tunnel cleanup happens on Drop (no zombie processes)"
  artifacts:
    - path: "packages/core/src/host/mod.rs"
      provides: "Public exports for host module"
      exports: ["HostConfig", "HostsFile", "HostError", "SshTunnel"]
    - path: "packages/core/src/host/schema.rs"
      provides: "HostConfig and HostsFile structs"
      contains: "pub struct HostConfig"
    - path: "packages/core/src/host/storage.rs"
      provides: "Load/save hosts.json functions"
      exports: ["load_hosts", "save_hosts"]
    - path: "packages/core/src/host/tunnel.rs"
      provides: "SSH tunnel management"
      contains: "impl Drop for SshTunnel"
    - path: "packages/core/src/host/error.rs"
      provides: "Host-specific error types"
      contains: "pub enum HostError"
    - path: "packages/core/src/config/paths.rs"
      provides: "get_hosts_path function"
      contains: "get_hosts_path"
  key_links:
    - from: "storage.rs load_hosts"
      to: "paths.rs get_hosts_path"
      via: "File path resolution"
      pattern: "get_hosts_path"
    - from: "tunnel.rs SshTunnel::new"
      to: "schema.rs HostConfig"
      via: "SSH options derived from config"
      pattern: "HostConfig"
    - from: "lib.rs"
      to: "host module"
      via: "pub mod host"
      pattern: "pub mod host"
---

<objective>
Create the core host management module with schema, storage, tunnel, and error types

Purpose: Establish the foundation for remote host management. This module provides data types for host configuration, file-based storage for hosts.json, SSH tunnel creation via system ssh, and error handling.

Output: New `packages/core/src/host/` module with complete CRUD for hosts.json and working SSH tunnel support
</objective>

<execution_context>
@~/.claude/get-shit-done/workflows/execute-plan.md
@~/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/11-remote-host-management/11-CONTEXT.md
@.planning/phases/11-remote-host-management/11-RESEARCH.md
@packages/core/src/config/mod.rs
@packages/core/src/config/paths.rs
@packages/core/src/docker/error.rs
@packages/core/src/lib.rs
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create host error types and schema</name>
  <files>packages/core/src/host/error.rs, packages/core/src/host/schema.rs</files>
  <action>
Create the host module directory and add error types and schema:

**1. Create packages/core/src/host/error.rs:**

```rust
//! Host-specific error types
//!
//! Errors that can occur during remote host operations.

use thiserror::Error;

/// Errors that can occur during host operations
#[derive(Error, Debug)]
pub enum HostError {
    /// Failed to spawn SSH process
    #[error("Failed to spawn SSH: {0}")]
    SshSpawn(String),

    /// SSH connection failed
    #[error("SSH connection failed: {0}")]
    ConnectionFailed(String),

    /// SSH authentication failed (key not in agent, passphrase needed)
    #[error("SSH authentication failed. Ensure your key is loaded: ssh-add {}", .key_hint.as_deref().unwrap_or("~/.ssh/id_rsa"))]
    AuthFailed {
        key_hint: Option<String>,
    },

    /// Host not found in hosts.json
    #[error("Host not found: {0}")]
    NotFound(String),

    /// Host already exists
    #[error("Host already exists: {0}")]
    AlreadyExists(String),

    /// Failed to allocate local port for tunnel
    #[error("Failed to allocate local port: {0}")]
    PortAllocation(String),

    /// Failed to load hosts file
    #[error("Failed to load hosts file: {0}")]
    LoadFailed(String),

    /// Failed to save hosts file
    #[error("Failed to save hosts file: {0}")]
    SaveFailed(String),

    /// Invalid host configuration
    #[error("Invalid host configuration: {0}")]
    InvalidConfig(String),

    /// Tunnel connection timed out
    #[error("SSH tunnel connection timed out after {0} attempts")]
    TunnelTimeout(u32),

    /// Remote Docker not available
    #[error("Docker not available on remote host: {0}")]
    RemoteDockerUnavailable(String),
}
```

**2. Create packages/core/src/host/schema.rs:**

```rust
//! Host configuration schema
//!
//! Data structures for storing remote host configurations.

use serde::{Deserialize, Serialize};
use std::collections::HashMap;

/// Configuration for a remote host
#[derive(Debug, Clone, Serialize, Deserialize, PartialEq)]
#[serde(deny_unknown_fields)]
pub struct HostConfig {
    /// SSH hostname or IP address
    pub hostname: String,

    /// SSH username (default: current user from whoami)
    #[serde(default = "default_user")]
    pub user: String,

    /// SSH port (default: 22)
    #[serde(default)]
    pub port: Option<u16>,

    /// Path to SSH identity file (private key)
    #[serde(default)]
    pub identity_file: Option<String>,

    /// Jump host for ProxyJump (user@host:port format)
    #[serde(default)]
    pub jump_host: Option<String>,

    /// Organization groups/tags for this host
    #[serde(default)]
    pub groups: Vec<String>,

    /// Optional description
    #[serde(default)]
    pub description: Option<String>,
}

fn default_user() -> String {
    whoami::username()
}

impl Default for HostConfig {
    fn default() -> Self {
        Self {
            hostname: String::new(),
            user: default_user(),
            port: None,
            identity_file: None,
            jump_host: None,
            groups: Vec::new(),
            description: None,
        }
    }
}

impl HostConfig {
    /// Create a new host config with just hostname
    pub fn new(hostname: impl Into<String>) -> Self {
        Self {
            hostname: hostname.into(),
            ..Default::default()
        }
    }

    /// Builder pattern: set user
    pub fn with_user(mut self, user: impl Into<String>) -> Self {
        self.user = user.into();
        self
    }

    /// Builder pattern: set port
    pub fn with_port(mut self, port: u16) -> Self {
        self.port = Some(port);
        self
    }

    /// Builder pattern: set identity file
    pub fn with_identity_file(mut self, path: impl Into<String>) -> Self {
        self.identity_file = Some(path.into());
        self
    }

    /// Builder pattern: set jump host
    pub fn with_jump_host(mut self, jump: impl Into<String>) -> Self {
        self.jump_host = Some(jump.into());
        self
    }

    /// Builder pattern: add group
    pub fn with_group(mut self, group: impl Into<String>) -> Self {
        self.groups.push(group.into());
        self
    }

    /// Builder pattern: set description
    pub fn with_description(mut self, desc: impl Into<String>) -> Self {
        self.description = Some(desc.into());
        self
    }
}

/// Root structure for hosts.json file
#[derive(Debug, Clone, Serialize, Deserialize, Default, PartialEq)]
#[serde(deny_unknown_fields)]
pub struct HostsFile {
    /// Schema version for future migrations
    #[serde(default = "default_version")]
    pub version: u32,

    /// Default host name (None = local Docker)
    #[serde(default)]
    pub default_host: Option<String>,

    /// Map of host name to configuration
    #[serde(default)]
    pub hosts: HashMap<String, HostConfig>,
}

fn default_version() -> u32 {
    1
}

impl HostsFile {
    /// Create empty hosts file
    pub fn new() -> Self {
        Self::default()
    }

    /// Add a host
    pub fn add_host(&mut self, name: impl Into<String>, config: HostConfig) {
        self.hosts.insert(name.into(), config);
    }

    /// Remove a host
    pub fn remove_host(&mut self, name: &str) -> Option<HostConfig> {
        // Clear default if removing the default host
        if self.default_host.as_deref() == Some(name) {
            self.default_host = None;
        }
        self.hosts.remove(name)
    }

    /// Get a host by name
    pub fn get_host(&self, name: &str) -> Option<&HostConfig> {
        self.hosts.get(name)
    }

    /// Get mutable reference to a host
    pub fn get_host_mut(&mut self, name: &str) -> Option<&mut HostConfig> {
        self.hosts.get_mut(name)
    }

    /// Check if host exists
    pub fn has_host(&self, name: &str) -> bool {
        self.hosts.contains_key(name)
    }

    /// Set the default host
    pub fn set_default(&mut self, name: Option<String>) {
        self.default_host = name;
    }

    /// Get list of host names
    pub fn host_names(&self) -> Vec<&str> {
        self.hosts.keys().map(|s| s.as_str()).collect()
    }
}

#[cfg(test)]
mod tests {
    use super::*;

    #[test]
    fn test_host_config_defaults() {
        let config = HostConfig::default();
        assert!(config.hostname.is_empty());
        assert!(!config.user.is_empty()); // Should be current user
        assert!(config.port.is_none());
        assert!(config.identity_file.is_none());
        assert!(config.jump_host.is_none());
        assert!(config.groups.is_empty());
        assert!(config.description.is_none());
    }

    #[test]
    fn test_host_config_builder() {
        let config = HostConfig::new("example.com")
            .with_user("admin")
            .with_port(2222)
            .with_identity_file("~/.ssh/prod_key")
            .with_group("production");

        assert_eq!(config.hostname, "example.com");
        assert_eq!(config.user, "admin");
        assert_eq!(config.port, Some(2222));
        assert_eq!(config.identity_file, Some("~/.ssh/prod_key".to_string()));
        assert_eq!(config.groups, vec!["production"]);
    }

    #[test]
    fn test_hosts_file_operations() {
        let mut hosts = HostsFile::new();
        assert!(hosts.hosts.is_empty());

        // Add host
        hosts.add_host("prod-1", HostConfig::new("prod1.example.com"));
        assert!(hosts.has_host("prod-1"));
        assert!(!hosts.has_host("prod-2"));

        // Set default
        hosts.set_default(Some("prod-1".to_string()));
        assert_eq!(hosts.default_host, Some("prod-1".to_string()));

        // Remove host clears default
        hosts.remove_host("prod-1");
        assert!(!hosts.has_host("prod-1"));
        assert!(hosts.default_host.is_none());
    }

    #[test]
    fn test_serialize_deserialize() {
        let mut hosts = HostsFile::new();
        hosts.add_host(
            "test",
            HostConfig::new("test.example.com")
                .with_user("testuser")
                .with_port(22),
        );

        let json = serde_json::to_string_pretty(&hosts).unwrap();
        let parsed: HostsFile = serde_json::from_str(&json).unwrap();

        assert_eq!(hosts, parsed);
    }

    #[test]
    fn test_deserialize_minimal() {
        // Minimal JSON should work with defaults
        let json = r#"{"version": 1}"#;
        let hosts: HostsFile = serde_json::from_str(json).unwrap();
        assert_eq!(hosts.version, 1);
        assert!(hosts.hosts.is_empty());
        assert!(hosts.default_host.is_none());
    }
}
```

Add whoami dependency to Cargo.toml:

```toml
# In packages/core/Cargo.toml [dependencies] section
whoami = "1.5"
```
  </action>
  <verify>Run `just build` - compilation succeeds with no warnings</verify>
  <done>Host error types and schema structs created with tests passing</done>
</task>

<task type="auto">
  <name>Task 2: Create host storage and paths integration</name>
  <files>packages/core/src/host/storage.rs, packages/core/src/config/paths.rs</files>
  <action>
Add hosts.json path resolution and storage functions:

**1. Update packages/core/src/config/paths.rs:**

Add a new function after `get_pid_path()`:

```rust
/// Get the full path to the hosts configuration file
///
/// Returns: `{config_dir}/hosts.json`
pub fn get_hosts_path() -> Option<PathBuf> {
    get_config_dir().map(|d| d.join("hosts.json"))
}
```

Add a test for it:

```rust
#[test]
fn test_hosts_path_ends_with_hosts_json() {
    let path = get_hosts_path();
    assert!(path.is_some());
    assert!(path.unwrap().ends_with("hosts.json"));
}
```

**2. Create packages/core/src/host/storage.rs:**

```rust
//! Host configuration storage
//!
//! Load and save hosts.json file.

use std::fs::{self, File};
use std::io::{Read, Write};

use crate::config::paths::get_hosts_path;
use super::error::HostError;
use super::schema::HostsFile;

/// Load hosts configuration from hosts.json
///
/// Returns empty HostsFile if file doesn't exist.
pub fn load_hosts() -> Result<HostsFile, HostError> {
    let hosts_path = get_hosts_path()
        .ok_or_else(|| HostError::LoadFailed("Could not determine hosts file path".to_string()))?;

    if !hosts_path.exists() {
        tracing::debug!("Hosts file not found, returning empty: {}", hosts_path.display());
        return Ok(HostsFile::new());
    }

    let mut file = File::open(&hosts_path)
        .map_err(|e| HostError::LoadFailed(format!("Failed to open {}: {}", hosts_path.display(), e)))?;

    let mut contents = String::new();
    file.read_to_string(&mut contents)
        .map_err(|e| HostError::LoadFailed(format!("Failed to read {}: {}", hosts_path.display(), e)))?;

    let hosts: HostsFile = serde_json::from_str(&contents)
        .map_err(|e| HostError::LoadFailed(format!("Invalid JSON in {}: {}", hosts_path.display(), e)))?;

    tracing::debug!("Loaded {} hosts from {}", hosts.hosts.len(), hosts_path.display());
    Ok(hosts)
}

/// Save hosts configuration to hosts.json
///
/// Creates the config directory if it doesn't exist.
/// Creates a backup (.bak) if file already exists.
pub fn save_hosts(hosts: &HostsFile) -> Result<(), HostError> {
    let hosts_path = get_hosts_path()
        .ok_or_else(|| HostError::SaveFailed("Could not determine hosts file path".to_string()))?;

    // Ensure config directory exists
    if let Some(parent) = hosts_path.parent() {
        if !parent.exists() {
            fs::create_dir_all(parent)
                .map_err(|e| HostError::SaveFailed(format!("Failed to create directory: {}", e)))?;
        }
    }

    // Create backup if file exists
    if hosts_path.exists() {
        let backup_path = hosts_path.with_extension("json.bak");
        fs::copy(&hosts_path, &backup_path)
            .map_err(|e| HostError::SaveFailed(format!("Failed to create backup: {}", e)))?;
        tracing::debug!("Created hosts backup: {}", backup_path.display());
    }

    // Serialize with pretty formatting
    let json = serde_json::to_string_pretty(hosts)
        .map_err(|e| HostError::SaveFailed(format!("Failed to serialize: {}", e)))?;

    // Write to file
    let mut file = File::create(&hosts_path)
        .map_err(|e| HostError::SaveFailed(format!("Failed to create {}: {}", hosts_path.display(), e)))?;

    file.write_all(json.as_bytes())
        .map_err(|e| HostError::SaveFailed(format!("Failed to write {}: {}", hosts_path.display(), e)))?;

    tracing::debug!("Saved {} hosts to {}", hosts.hosts.len(), hosts_path.display());
    Ok(())
}

#[cfg(test)]
mod tests {
    use super::*;
    use crate::host::schema::HostConfig;

    #[test]
    fn test_load_nonexistent_returns_empty() {
        // This test relies on hosts.json not existing in a fresh environment
        // In CI/testing, we'd mock the path, but for basic test:
        let result = load_hosts();
        // Should succeed with empty or existing hosts
        assert!(result.is_ok());
    }

    #[test]
    fn test_serialize_format() {
        let mut hosts = HostsFile::new();
        hosts.add_host("test", HostConfig::new("test.example.com"));

        let json = serde_json::to_string_pretty(&hosts).unwrap();

        // Verify it's valid JSON that can be read back
        let parsed: HostsFile = serde_json::from_str(&json).unwrap();
        assert!(parsed.has_host("test"));
    }
}
```
  </action>
  <verify>Run `just test` - all tests pass including new hosts path test</verify>
  <done>Storage functions and paths.rs extension complete</done>
</task>

<task type="auto">
  <name>Task 3: Create SSH tunnel management and wire up module</name>
  <files>packages/core/src/host/tunnel.rs, packages/core/src/host/mod.rs, packages/core/src/lib.rs</files>
  <action>
Create the SSH tunnel implementation and wire up the module:

**1. Create packages/core/src/host/tunnel.rs:**

```rust
//! SSH tunnel management
//!
//! Creates and manages SSH tunnels to remote Docker daemons.

use std::net::TcpListener;
use std::process::{Child, Command, Stdio};
use std::time::Duration;

use super::error::HostError;
use super::schema::HostConfig;

/// SSH tunnel to a remote Docker daemon
///
/// The tunnel forwards a local port to the remote Docker socket.
/// Implements Drop to ensure the SSH process is killed on cleanup.
pub struct SshTunnel {
    child: Child,
    local_port: u16,
    host_name: String,
}

impl SshTunnel {
    /// Create SSH tunnel to remote Docker socket
    ///
    /// Spawns an SSH process with local port forwarding:
    /// `ssh -L local_port:/var/run/docker.sock -N host`
    ///
    /// Uses BatchMode=yes to fail fast if key not in agent.
    pub fn new(host: &HostConfig, host_name: &str) -> Result<Self, HostError> {
        // Find available local port
        let local_port = find_available_port()?;

        // Build SSH command
        let mut cmd = Command::new("ssh");

        // Local port forward: local_port -> remote docker.sock
        cmd.arg("-L")
            .arg(format!("{}:/var/run/docker.sock", local_port));

        // No command, just forward
        cmd.arg("-N");

        // Suppress prompts, fail fast on auth issues
        cmd.arg("-o").arg("BatchMode=yes");

        // Accept new host keys automatically (first connection)
        cmd.arg("-o").arg("StrictHostKeyChecking=accept-new");

        // Connection timeout
        cmd.arg("-o").arg("ConnectTimeout=10");

        // Prevent SSH from reading stdin (fixes issues with background operation)
        cmd.arg("-o").arg("RequestTTY=no");

        // Jump host support
        if let Some(jump) = &host.jump_host {
            cmd.arg("-J").arg(jump);
        }

        // Identity file
        if let Some(key) = &host.identity_file {
            cmd.arg("-i").arg(key);
        }

        // Custom port
        if let Some(port) = host.port {
            cmd.arg("-p").arg(port.to_string());
        }

        // Target: user@hostname
        cmd.arg(format!("{}@{}", host.user, host.hostname));

        // Configure stdio
        cmd.stdin(Stdio::null())
            .stdout(Stdio::null())
            .stderr(Stdio::piped());

        tracing::debug!(
            "Spawning SSH tunnel: ssh -L {}:/var/run/docker.sock {}@{}",
            local_port,
            host.user,
            host.hostname
        );

        let child = cmd.spawn().map_err(|e| {
            if e.kind() == std::io::ErrorKind::NotFound {
                HostError::SshSpawn("SSH not found. Install OpenSSH client.".to_string())
            } else {
                HostError::SshSpawn(e.to_string())
            }
        })?;

        Ok(Self {
            child,
            local_port,
            host_name: host_name.to_string(),
        })
    }

    /// Get the local port for Docker connection
    pub fn local_port(&self) -> u16 {
        self.local_port
    }

    /// Get the Docker connection URL
    pub fn docker_url(&self) -> String {
        format!("tcp://127.0.0.1:{}", self.local_port)
    }

    /// Get the host name this tunnel connects to
    pub fn host_name(&self) -> &str {
        &self.host_name
    }

    /// Wait for tunnel to be ready (port accepting connections)
    ///
    /// Retries with exponential backoff: 100ms, 200ms, 400ms (3 attempts)
    pub async fn wait_ready(&self) -> Result<(), HostError> {
        let max_attempts = 3;
        let initial_delay_ms = 100;

        for attempt in 0..max_attempts {
            if attempt > 0 {
                let delay = Duration::from_millis(initial_delay_ms * 2u64.pow(attempt as u32));
                tracing::debug!("Tunnel wait attempt {} after {:?}", attempt + 1, delay);
                tokio::time::sleep(delay).await;
            }

            // Try to connect to the local port
            match std::net::TcpStream::connect_timeout(
                &format!("127.0.0.1:{}", self.local_port).parse().unwrap(),
                Duration::from_secs(1),
            ) {
                Ok(_) => {
                    tracing::debug!("SSH tunnel ready on port {}", self.local_port);
                    return Ok(());
                }
                Err(e) => {
                    tracing::debug!("Tunnel not ready: {}", e);
                }
            }
        }

        Err(HostError::TunnelTimeout(max_attempts))
    }

    /// Check if the SSH process is still running
    pub fn is_alive(&mut self) -> bool {
        matches!(self.child.try_wait(), Ok(None))
    }
}

impl Drop for SshTunnel {
    fn drop(&mut self) {
        tracing::debug!("Cleaning up SSH tunnel to {} (port {})", self.host_name, self.local_port);
        if let Err(e) = self.child.kill() {
            // Process may have already exited
            tracing::debug!("SSH tunnel kill result: {}", e);
        }
        // Wait to reap the zombie process
        let _ = self.child.wait();
    }
}

/// Find an available local port for the tunnel
fn find_available_port() -> Result<u16, HostError> {
    // Bind to port 0 to get OS-assigned port
    let listener = TcpListener::bind("127.0.0.1:0")
        .map_err(|e| HostError::PortAllocation(e.to_string()))?;

    let port = listener
        .local_addr()
        .map_err(|e| HostError::PortAllocation(e.to_string()))?
        .port();

    // Drop listener to free the port
    drop(listener);

    Ok(port)
}

/// Test SSH connection to a host
///
/// Runs `ssh user@host docker version` to verify:
/// 1. SSH connection works
/// 2. Docker is available on remote
pub async fn test_connection(host: &HostConfig) -> Result<String, HostError> {
    let mut cmd = Command::new("ssh");

    // Standard options
    cmd.arg("-o").arg("BatchMode=yes")
        .arg("-o").arg("ConnectTimeout=10")
        .arg("-o").arg("StrictHostKeyChecking=accept-new");

    // Host-specific options
    if let Some(port) = host.port {
        cmd.arg("-p").arg(port.to_string());
    }
    if let Some(key) = &host.identity_file {
        cmd.arg("-i").arg(key);
    }
    if let Some(jump) = &host.jump_host {
        cmd.arg("-J").arg(jump);
    }

    // Target with Docker version command
    cmd.arg(format!("{}@{}", host.user, host.hostname))
        .arg("docker")
        .arg("version")
        .arg("--format")
        .arg("{{.Server.Version}}");

    cmd.stdin(Stdio::null())
        .stdout(Stdio::piped())
        .stderr(Stdio::piped());

    let output = cmd.output().map_err(|e| {
        if e.kind() == std::io::ErrorKind::NotFound {
            HostError::SshSpawn("SSH not found. Install OpenSSH client.".to_string())
        } else {
            HostError::SshSpawn(e.to_string())
        }
    })?;

    if output.status.success() {
        let version = String::from_utf8_lossy(&output.stdout).trim().to_string();
        tracing::info!("Docker version on remote: {}", version);
        Ok(version)
    } else {
        let stderr = String::from_utf8_lossy(&output.stderr);

        // Detect authentication failures
        if stderr.contains("Permission denied") || stderr.contains("Host key verification failed") {
            return Err(HostError::AuthFailed {
                key_hint: host.identity_file.clone(),
            });
        }

        // Detect Docker not available
        if stderr.contains("command not found") || stderr.contains("not found") {
            return Err(HostError::RemoteDockerUnavailable(
                "Docker is not installed on remote host".to_string(),
            ));
        }

        Err(HostError::ConnectionFailed(stderr.to_string()))
    }
}

#[cfg(test)]
mod tests {
    use super::*;

    #[test]
    fn test_find_available_port() {
        let port = find_available_port().unwrap();
        assert!(port > 0);

        // Port should be available (we can bind to it)
        let listener = TcpListener::bind(format!("127.0.0.1:{}", port));
        assert!(listener.is_ok());
    }

    #[test]
    fn test_docker_url_format() {
        // We can't easily test tunnel creation without SSH, but we can test the URL format
        let url = format!("tcp://127.0.0.1:{}", 12345);
        assert_eq!(url, "tcp://127.0.0.1:12345");
    }
}
```

**2. Create packages/core/src/host/mod.rs:**

```rust
//! Host management module
//!
//! Provides functionality for managing remote Docker hosts:
//! - Host configuration schema and storage
//! - SSH tunnel management for remote Docker access
//! - Connection testing and validation

mod error;
mod schema;
mod storage;
mod tunnel;

// Public exports
pub use error::HostError;
pub use schema::{HostConfig, HostsFile};
pub use storage::{load_hosts, save_hosts};
pub use tunnel::{SshTunnel, test_connection};
```

**3. Update packages/core/src/lib.rs:**

Add the host module and re-exports after the existing modules:

```rust
pub mod host;

// Re-export host types
pub use host::{HostConfig, HostError, HostsFile, SshTunnel, load_hosts, save_hosts, test_connection};
```

**4. Update packages/core/Cargo.toml:**

Add the whoami dependency if not present:

```toml
whoami = "1.5"
```
  </action>
  <verify>Run `just build && just test` - all tests pass, no warnings</verify>
  <done>Complete host module with tunnel support, wired into core library</done>
</task>

</tasks>

<verification>
1. packages/core/src/host/ directory exists with 5 files
2. HostConfig struct has all required fields (hostname, user, port, identity_file, jump_host, groups, description)
3. HostsFile struct has version, default_host, hosts HashMap
4. load_hosts() returns empty HostsFile when file doesn't exist
5. save_hosts() creates backup before overwriting
6. get_hosts_path() returns ~/.config/opencode-cloud/hosts.json
7. SshTunnel implements Drop to kill SSH process
8. SshTunnel::new() uses BatchMode=yes and StrictHostKeyChecking=accept-new
9. test_connection() verifies both SSH and Docker availability
10. All types exported from packages/core/src/lib.rs
11. `just build` succeeds with no warnings
12. `just test` passes all tests
</verification>

<success_criteria>
- New host module created at packages/core/src/host/
- HostConfig and HostsFile structs serialize/deserialize correctly
- SSH tunnel spawns with correct options and cleans up on Drop
- hosts.json path integrated into config/paths.rs
- Module exported from core library
- All tests pass
</success_criteria>

<output>
After completion, create `.planning/phases/11-remote-host-management/11-01-SUMMARY.md`
</output>
