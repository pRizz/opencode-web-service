---
phase: 11-remote-host-management
plan: 03
type: execute
wave: 3
depends_on: ["11-01", "11-02"]
files_modified:
  - packages/core/src/docker/client.rs
  - packages/core/src/docker/mod.rs
  - packages/cli-rust/src/lib.rs
  - packages/cli-rust/src/commands/start.rs
  - packages/cli-rust/src/commands/stop.rs
  - packages/cli-rust/src/commands/restart.rs
  - packages/cli-rust/src/commands/status.rs
  - packages/cli-rust/src/commands/logs.rs
  - packages/cli-rust/src/commands/update.rs
  - packages/cli-rust/src/commands/cockpit.rs
  - packages/cli-rust/src/commands/user/mod.rs
autonomous: true

must_haves:
  truths:
    - "User can run occ start --host prod-1 to start on remote host"
    - "User can run occ status --host prod-1 to check remote status"
    - "All container commands support --host flag"
    - "Remote output is prefixed with host name [prod-1]"
    - "Default host is used when --host not specified"
    - "Local Docker is used when no default and no --host"
    - "SSH tunnel is created automatically for remote operations"
  artifacts:
    - path: "packages/core/src/docker/client.rs"
      provides: "DockerClient::connect_remote for SSH tunnel connections"
      contains: "connect_remote"
    - path: "packages/cli-rust/src/lib.rs"
      provides: "Global --host flag on CLI struct"
      contains: "#[arg(long, global = true)]"
    - path: "packages/cli-rust/src/commands/start.rs"
      provides: "Start command with remote host support"
      contains: "host_name"
  key_links:
    - from: "lib.rs Cli.host"
      to: "commands/start.rs"
      via: "Host passed to command handlers"
      pattern: "host"
    - from: "commands/start.rs"
      to: "client.rs connect_remote"
      via: "Create remote DockerClient when host specified"
      pattern: "connect_remote"
    - from: "client.rs connect_remote"
      to: "host/tunnel.rs SshTunnel"
      via: "SSH tunnel creation"
      pattern: "SshTunnel"
---

<objective>
Add --host flag to all container commands and wire remote Docker connections

Purpose: Enable all existing container commands (start, stop, restart, status, logs, update, cockpit, user) to operate on remote hosts via SSH tunnel. This is the final piece that makes the remote host management feature complete.

Output: All container commands support --host flag, output prefixed with host name for remote operations
</objective>

<execution_context>
@~/.claude/get-shit-done/workflows/execute-plan.md
@~/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/11-remote-host-management/11-CONTEXT.md
@.planning/phases/11-remote-host-management/11-RESEARCH.md
@.planning/phases/11-remote-host-management/11-01-SUMMARY.md
@.planning/phases/11-remote-host-management/11-02-SUMMARY.md
@packages/core/src/docker/client.rs
@packages/core/src/docker/mod.rs
@packages/cli-rust/src/lib.rs
@packages/cli-rust/src/commands/start.rs
@packages/cli-rust/src/commands/status.rs
</context>

<tasks>

<task type="auto">
  <name>Task 1: Extend DockerClient with remote connection support</name>
  <files>packages/core/src/docker/client.rs, packages/core/src/docker/mod.rs</files>
  <action>
Add connect_remote method to DockerClient that uses SSH tunnels:

**1. Update packages/core/src/docker/client.rs:**

Replace the entire file with:

```rust
//! Docker client wrapper with connection handling
//!
//! This module provides a wrapped Docker client that handles connection
//! errors gracefully and provides clear error messages.

use bollard::Docker;
use std::time::Duration;

use super::error::DockerError;
use crate::host::{HostConfig, HostError, SshTunnel};

/// Docker client wrapper with connection handling
pub struct DockerClient {
    inner: Docker,
    /// SSH tunnel for remote connections (kept alive for client lifetime)
    _tunnel: Option<SshTunnel>,
    /// Host name for remote connections (None = local)
    host_name: Option<String>,
}

impl DockerClient {
    /// Create new client connecting to local Docker daemon
    ///
    /// Uses platform-appropriate socket (Unix socket on Linux/macOS).
    /// Returns a clear error if Docker is not running or accessible.
    pub fn new() -> Result<Self, DockerError> {
        let docker = Docker::connect_with_local_defaults()
            .map_err(|e| DockerError::Connection(e.to_string()))?;

        Ok(Self {
            inner: docker,
            _tunnel: None,
            host_name: None,
        })
    }

    /// Create client with custom timeout (in seconds)
    ///
    /// Use for long-running operations like image builds.
    /// Default timeout is 120 seconds; build timeout should be 600+ seconds.
    pub fn with_timeout(timeout_secs: u64) -> Result<Self, DockerError> {
        let docker = Docker::connect_with_local_defaults()
            .map_err(|e| DockerError::Connection(e.to_string()))?
            .with_timeout(Duration::from_secs(timeout_secs));

        Ok(Self {
            inner: docker,
            _tunnel: None,
            host_name: None,
        })
    }

    /// Create client connecting to remote Docker daemon via SSH tunnel
    ///
    /// Establishes an SSH tunnel to the remote host and connects Bollard
    /// to the forwarded local port.
    ///
    /// # Arguments
    /// * `host` - Remote host configuration
    /// * `host_name` - Name of the host (for display purposes)
    pub async fn connect_remote(host: &HostConfig, host_name: &str) -> Result<Self, DockerError> {
        // Create SSH tunnel
        let tunnel = SshTunnel::new(host, host_name)
            .map_err(|e| DockerError::Connection(format!("SSH tunnel failed: {}", e)))?;

        // Wait for tunnel to be ready with exponential backoff
        tunnel.wait_ready().await
            .map_err(|e| DockerError::Connection(format!("SSH tunnel not ready: {}", e)))?;

        // Connect Bollard to the tunnel's local port
        let docker_url = tunnel.docker_url();
        tracing::debug!("Connecting to remote Docker via {}", docker_url);

        // Retry connection with backoff (tunnel may need a moment)
        let max_attempts = 3;
        let mut last_err = None;

        for attempt in 0..max_attempts {
            if attempt > 0 {
                let delay = Duration::from_millis(100 * 2u64.pow(attempt as u32));
                tracing::debug!("Retry attempt {} after {:?}", attempt + 1, delay);
                tokio::time::sleep(delay).await;
            }

            match Docker::connect_with_http(&docker_url, 120, bollard::API_DEFAULT_VERSION) {
                Ok(docker) => {
                    // Verify connection works
                    match docker.ping().await {
                        Ok(_) => {
                            tracing::info!(
                                "Connected to Docker on {} via SSH tunnel",
                                host_name
                            );
                            return Ok(Self {
                                inner: docker,
                                _tunnel: Some(tunnel),
                                host_name: Some(host_name.to_string()),
                            });
                        }
                        Err(e) => {
                            tracing::debug!("Ping failed: {}", e);
                            last_err = Some(e.to_string());
                        }
                    }
                }
                Err(e) => {
                    tracing::debug!("Connection failed: {}", e);
                    last_err = Some(e.to_string());
                }
            }
        }

        Err(DockerError::Connection(format!(
            "Failed to connect to Docker on {}: {}",
            host_name,
            last_err.unwrap_or_else(|| "unknown error".to_string())
        )))
    }

    /// Create remote client with custom timeout
    pub async fn connect_remote_with_timeout(
        host: &HostConfig,
        host_name: &str,
        timeout_secs: u64,
    ) -> Result<Self, DockerError> {
        let tunnel = SshTunnel::new(host, host_name)
            .map_err(|e| DockerError::Connection(format!("SSH tunnel failed: {}", e)))?;

        tunnel.wait_ready().await
            .map_err(|e| DockerError::Connection(format!("SSH tunnel not ready: {}", e)))?;

        let docker_url = tunnel.docker_url();

        let docker = Docker::connect_with_http(&docker_url, timeout_secs, bollard::API_DEFAULT_VERSION)
            .map_err(|e| DockerError::Connection(e.to_string()))?;

        // Verify connection
        docker.ping().await.map_err(DockerError::from)?;

        Ok(Self {
            inner: docker,
            _tunnel: Some(tunnel),
            host_name: Some(host_name.to_string()),
        })
    }

    /// Verify connection to Docker daemon
    ///
    /// Returns Ok(()) if connected, descriptive error otherwise.
    pub async fn verify_connection(&self) -> Result<(), DockerError> {
        self.inner.ping().await.map_err(DockerError::from)?;
        Ok(())
    }

    /// Get Docker version info (useful for debugging)
    pub async fn version(&self) -> Result<String, DockerError> {
        let version = self.inner.version().await.map_err(DockerError::from)?;

        let version_str = format!(
            "Docker {} (API {})",
            version.version.unwrap_or_else(|| "unknown".to_string()),
            version.api_version.unwrap_or_else(|| "unknown".to_string())
        );

        Ok(version_str)
    }

    /// Get the host name if this is a remote connection
    pub fn host_name(&self) -> Option<&str> {
        self.host_name.as_deref()
    }

    /// Check if this is a remote connection
    pub fn is_remote(&self) -> bool {
        self._tunnel.is_some()
    }

    /// Access inner Bollard client for advanced operations
    pub fn inner(&self) -> &Docker {
        &self.inner
    }
}

#[cfg(test)]
mod tests {
    use super::*;

    #[test]
    fn docker_client_creation_does_not_panic() {
        // This test just verifies the code compiles and doesn't panic
        // Actual connection test requires Docker to be running
        let result = DockerClient::new();
        // We don't assert success because Docker may not be running in CI
        drop(result);
    }

    #[test]
    fn docker_client_with_timeout_does_not_panic() {
        let result = DockerClient::with_timeout(600);
        drop(result);
    }

    #[test]
    fn test_host_name_methods() {
        // Local client has no host name
        if let Ok(client) = DockerClient::new() {
            assert!(client.host_name().is_none());
            assert!(!client.is_remote());
        }
    }
}
```

**2. Update packages/core/src/docker/mod.rs:**

Add the connect_remote export. In the pub use client line:

```rust
pub use client::{DockerClient};
```

No additional changes needed since connect_remote is an inherent method on DockerClient.
  </action>
  <verify>Run `just build` - compilation succeeds with no warnings</verify>
  <done>DockerClient extended with connect_remote method for SSH tunnel connections</done>
</task>

<task type="auto">
  <name>Task 2: Add global --host flag and helper for client resolution</name>
  <files>packages/cli-rust/src/lib.rs</files>
  <action>
Add the global --host flag and create a helper function for resolving the Docker client:

**Update packages/cli-rust/src/lib.rs:**

1. Add the --host flag to the Cli struct (after no_color):

```rust
    /// Target remote host (overrides default_host)
    #[arg(long, global = true)]
    host: Option<String>,
```

2. Add imports at the top of the file:

```rust
use opencode_cloud_core::{
    InstanceLock, SingletonError, config, get_version, load_config, save_config,
    load_hosts, DockerClient,
};
```

3. Add a new helper function after the Cli struct but before `fn run()`:

```rust
/// Resolve which Docker client to use based on --host flag and default_host config
///
/// Returns (DockerClient, Option<host_name>) where host_name is Some for remote connections.
///
/// Resolution order:
/// 1. --host flag (explicit)
/// 2. default_host from hosts.json
/// 3. Local Docker (no host_name)
pub async fn resolve_docker_client(
    maybe_host: Option<&str>,
) -> anyhow::Result<(DockerClient, Option<String>)> {
    let hosts = load_hosts().unwrap_or_default();

    // Determine target host
    let target_host = maybe_host
        .map(String::from)
        .or_else(|| hosts.default_host.clone());

    match target_host {
        Some(name) if name != "local" && !name.is_empty() => {
            // Remote host requested
            let host_config = hosts.get_host(&name).ok_or_else(|| {
                anyhow::anyhow!(
                    "Host '{}' not found. Run 'occ host list' to see available hosts.",
                    name
                )
            })?;

            let client = DockerClient::connect_remote(host_config, &name).await?;
            Ok((client, Some(name)))
        }
        _ => {
            // Local Docker
            let client = DockerClient::new()?;
            Ok((client, None))
        }
    }
}

/// Format a message with optional host prefix
///
/// For remote hosts: "[prod-1] Starting container..."
/// For local: "Starting container..."
pub fn format_host_message(host_name: Option<&str>, message: &str) -> String {
    match host_name {
        Some(name) => format!("[{}] {}", style(name).cyan(), message),
        None => message.to_string(),
    }
}
```

4. Update the run() function signature and pass host to commands that need it. The commands will be updated in the next task, but we need to pass cli.host through:

At the start of run(), after loading config, add:

```rust
    // Store host flag for command handlers
    let target_host = cli.host.clone();
```

Then update the command handlers to pass the host. For now, just update the function signatures in the match - the actual command implementations will be updated in Task 3.

Update each container command call to include the host parameter:

```rust
        Some(Commands::Start(args)) => {
            let rt = tokio::runtime::Runtime::new()?;
            rt.block_on(commands::cmd_start(&args, target_host.as_deref(), cli.quiet, cli.verbose))
        }
        Some(Commands::Stop(args)) => {
            let rt = tokio::runtime::Runtime::new()?;
            rt.block_on(commands::cmd_stop(&args, target_host.as_deref(), cli.quiet))
        }
        Some(Commands::Restart(args)) => {
            let rt = tokio::runtime::Runtime::new()?;
            rt.block_on(commands::cmd_restart(&args, target_host.as_deref(), cli.quiet, cli.verbose))
        }
        Some(Commands::Status(args)) => {
            let rt = tokio::runtime::Runtime::new()?;
            rt.block_on(commands::cmd_status(&args, target_host.as_deref(), cli.quiet, cli.verbose))
        }
        Some(Commands::Logs(args)) => {
            let rt = tokio::runtime::Runtime::new()?;
            rt.block_on(commands::cmd_logs(&args, target_host.as_deref(), cli.quiet))
        }
        Some(Commands::User(args)) => {
            let rt = tokio::runtime::Runtime::new()?;
            rt.block_on(commands::cmd_user(&args, target_host.as_deref(), cli.quiet, cli.verbose))
        }
        Some(Commands::Update(args)) => {
            let rt = tokio::runtime::Runtime::new()?;
            rt.block_on(commands::cmd_update(&args, target_host.as_deref(), cli.quiet, cli.verbose))
        }
        Some(Commands::Cockpit(args)) => {
            let rt = tokio::runtime::Runtime::new()?;
            rt.block_on(commands::cmd_cockpit(&args, target_host.as_deref(), cli.quiet))
        }
```

Note: Install and Uninstall don't need --host as they operate on local service registration. Config and Setup don't need --host as they operate on local config files. Host commands manage hosts.json, not containers.

Also export the helpers from lib.rs:

Add at the end of the module:

```rust
// Export helpers for commands
pub use crate::resolve_docker_client;
pub use crate::format_host_message;
```

Wait, these are in lib.rs itself so we need a different approach. Make them pub and they'll be available within the crate:

Actually, the functions are already in lib.rs and commands are a submodule, so they can access them via `crate::resolve_docker_client` and `crate::format_host_message`. Let's use `super::` in the command modules.
  </action>
  <verify>Run `just build` - may have errors since command signatures changed but not implementations yet</verify>
  <done>Global --host flag added to CLI with helper functions for client resolution</done>
</task>

<task type="auto">
  <name>Task 3: Update container commands to support --host flag</name>
  <files>packages/cli-rust/src/commands/start.rs, packages/cli-rust/src/commands/stop.rs, packages/cli-rust/src/commands/restart.rs, packages/cli-rust/src/commands/status.rs, packages/cli-rust/src/commands/logs.rs, packages/cli-rust/src/commands/update.rs, packages/cli-rust/src/commands/cockpit.rs, packages/cli-rust/src/commands/user/mod.rs</files>
  <action>
Update each container command to accept the host parameter and use remote Docker when specified:

**1. Update packages/cli-rust/src/commands/start.rs:**

Update the function signature:

```rust
pub async fn cmd_start(
    args: &StartArgs,
    maybe_host: Option<&str>,
    quiet: bool,
    verbose: u8,
) -> Result<()> {
```

Near the top of the function, resolve the Docker client:

```rust
    // Resolve Docker client (local or remote)
    let (client, host_name) = crate::resolve_docker_client(maybe_host).await?;

    // Helper for prefixed output
    let prefix = |msg: &str| crate::format_host_message(host_name.as_deref(), msg);
```

Then update all println! and eprintln! calls to use the prefix where appropriate. For example:

```rust
    if !quiet {
        println!("{}", prefix(&format!("Container created: {}", &container_id[..12])));
    }
```

For messages that should always show the host context, use prefix(). For general status messages that don't need prefixing (like tips), leave them as-is.

Key places to prefix:
- "Starting container..."
- "Container started"
- "Service is now running"
- URLs (but note: remote URLs would need the remote hostname, which is more complex - for now, just add a note that the URL is for the local tunnel)

**2. Update packages/cli-rust/src/commands/stop.rs:**

```rust
pub async fn cmd_stop(args: &StopArgs, maybe_host: Option<&str>, quiet: bool) -> Result<()> {
    let (client, host_name) = crate::resolve_docker_client(maybe_host).await?;
    let prefix = |msg: &str| crate::format_host_message(host_name.as_deref(), msg);

    // ... rest of implementation with prefixed output
}
```

**3. Update packages/cli-rust/src/commands/restart.rs:**

```rust
pub async fn cmd_restart(
    args: &RestartArgs,
    maybe_host: Option<&str>,
    quiet: bool,
    verbose: u8,
) -> Result<()> {
    let (client, host_name) = crate::resolve_docker_client(maybe_host).await?;
    let prefix = |msg: &str| crate::format_host_message(host_name.as_deref(), msg);

    // ... rest of implementation with prefixed output
}
```

**4. Update packages/cli-rust/src/commands/status.rs:**

```rust
pub async fn cmd_status(
    args: &StatusArgs,
    maybe_host: Option<&str>,
    quiet: bool,
    verbose: u8,
) -> Result<()> {
    let (client, host_name) = crate::resolve_docker_client(maybe_host).await?;

    // For status, show the host being queried at the top
    if !quiet && host_name.is_some() {
        println!("{}", crate::format_host_message(host_name.as_deref(), "Status"));
        println!();
    }

    // ... rest of implementation
}
```

**5. Update packages/cli-rust/src/commands/logs.rs:**

```rust
pub async fn cmd_logs(args: &LogsArgs, maybe_host: Option<&str>, quiet: bool) -> Result<()> {
    let (client, host_name) = crate::resolve_docker_client(maybe_host).await?;

    // For logs, optionally prefix each line with host name
    // This helps identify source when tailing multiple hosts
    let line_prefix = host_name.as_ref().map(|n| format!("[{}] ", style(n).cyan()));

    // ... in the log streaming loop, prepend line_prefix if Some
}
```

**6. Update packages/cli-rust/src/commands/update.rs:**

```rust
pub async fn cmd_update(
    args: &UpdateArgs,
    maybe_host: Option<&str>,
    quiet: bool,
    verbose: u8,
) -> Result<()> {
    let (client, host_name) = crate::resolve_docker_client(maybe_host).await?;
    let prefix = |msg: &str| crate::format_host_message(host_name.as_deref(), msg);

    // ... rest of implementation with prefixed output
}
```

**7. Update packages/cli-rust/src/commands/cockpit.rs:**

```rust
pub async fn cmd_cockpit(args: &CockpitArgs, maybe_host: Option<&str>, quiet: bool) -> Result<()> {
    let (client, host_name) = crate::resolve_docker_client(maybe_host).await?;

    // Note: For remote hosts, the Cockpit URL would need to be accessed
    // through the remote host's network. For now, just show the remote
    // host's configured hostname.

    // ... rest of implementation
}
```

**8. Update packages/cli-rust/src/commands/user/mod.rs:**

```rust
pub async fn cmd_user(args: &UserArgs, maybe_host: Option<&str>, quiet: bool, verbose: u8) -> Result<()> {
    // Resolve Docker client (local or remote)
    let (client, host_name) = crate::resolve_docker_client(maybe_host).await?;

    // Check container is running
    if !container_is_running(&client, CONTAINER_NAME).await? {
        let msg = if let Some(name) = &host_name {
            format!("Container not running on {}. Start with `occ start --host {}`.", name, name)
        } else {
            "Container not running. Start with `occ start` first.".to_string()
        };
        bail!(msg);
    }

    // Pass client to subcommands (they currently create their own client, so they need updating too)
    // ... This requires updating the subcommand functions to accept a client parameter
}
```

For the user subcommands (add, remove, list, passwd, enable), they currently create their own DockerClient. Update them to accept a DockerClient reference:

In each user subcommand file, update the function signature to accept &DockerClient:

```rust
pub async fn cmd_user_add(client: &DockerClient, args: &UserAddArgs, quiet: bool, verbose: u8) -> Result<()> {
    // Remove the DockerClient::new() call
    // Use the passed client instead
}
```

Then update user/mod.rs to pass the client:

```rust
match &args.command {
    UserCommands::Add(add_args) => add::cmd_user_add(&client, add_args, quiet, verbose).await,
    UserCommands::Remove(remove_args) => remove::cmd_user_remove(&client, remove_args, quiet, verbose).await,
    // ... etc
}
```

**Summary of signature changes:**

| Command | Old Signature | New Signature |
|---------|---------------|---------------|
| cmd_start | (args, quiet, verbose) | (args, maybe_host, quiet, verbose) |
| cmd_stop | (args, quiet) | (args, maybe_host, quiet) |
| cmd_restart | (args, quiet, verbose) | (args, maybe_host, quiet, verbose) |
| cmd_status | (args, quiet, verbose) | (args, maybe_host, quiet, verbose) |
| cmd_logs | (args, quiet) | (args, maybe_host, quiet) |
| cmd_user | (args, quiet, verbose) | (args, maybe_host, quiet, verbose) |
| cmd_update | (args, quiet, verbose) | (args, maybe_host, quiet, verbose) |
| cmd_cockpit | (args, quiet) | (args, maybe_host, quiet) |
  </action>
  <verify>Run `just build && just test` - all tests pass, `occ start --help` shows --host flag</verify>
  <done>All container commands updated to support --host flag with prefixed output</done>
</task>

</tasks>

<verification>
1. `occ --help` shows global `--host` flag
2. `occ start --host prod-1` attempts SSH tunnel to prod-1
3. `occ status` uses default_host if set, local Docker otherwise
4. `occ status --host prod-1` explicitly targets prod-1
5. `occ status --host local` forces local Docker even if default set
6. Remote output shows `[prod-1]` prefix: `[prod-1] Container running...`
7. `occ logs --host prod-1` streams logs with host prefix on each line
8. `occ user list --host prod-1` lists users on remote container
9. SSH tunnel is cleaned up when command completes (no zombie processes)
10. Connection errors show clear messages with troubleshooting hints
11. `just build` succeeds with no warnings
12. `just test` passes all tests
</verification>

<success_criteria>
- DockerClient has connect_remote method using SSH tunnels
- Global --host flag added to CLI
- All container commands (start, stop, restart, status, logs, update, cockpit, user) support --host
- Remote output prefixed with host name for clarity
- Default host resolution: --host flag > default_host > local
- SSH tunnel lifecycle managed correctly (created on command, cleaned on exit)
- Error messages provide actionable guidance for connection failures
</success_criteria>

<output>
After completion, create `.planning/phases/11-remote-host-management/11-03-SUMMARY.md`
</output>
