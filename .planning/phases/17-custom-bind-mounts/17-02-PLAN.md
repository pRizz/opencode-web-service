---
phase: 17-custom-bind-mounts
plan: 02
type: execute
wave: 2
depends_on: ["17-01"]
files_modified:
  - packages/cli-rust/src/commands/mount/mod.rs
  - packages/cli-rust/src/commands/mount/add.rs
  - packages/cli-rust/src/commands/mount/remove.rs
  - packages/cli-rust/src/commands/mount/list.rs
  - packages/cli-rust/src/commands/mod.rs
  - packages/cli-rust/src/lib.rs
  - packages/cli-rust/src/commands/start.rs
autonomous: true

must_haves:
  truths:
    - "User can add a bind mount via `occ mount add /host:/container`"
    - "User can add a read-only mount via `occ mount add /host:/container:ro`"
    - "User can remove a mount via `occ mount remove /host/path`"
    - "User can list configured mounts via `occ mount list`"
    - "User can add one-time mounts via `occ start --mount /a:/b`"
    - "User can skip config mounts via `occ start --no-mounts`"
  artifacts:
    - path: "packages/cli-rust/src/commands/mount/mod.rs"
      provides: "Mount subcommand group (MountArgs, MountCommands)"
      exports: ["MountArgs", "cmd_mount"]
    - path: "packages/cli-rust/src/commands/mount/add.rs"
      provides: "occ mount add implementation"
      exports: ["cmd_mount_add", "MountAddArgs"]
    - path: "packages/cli-rust/src/commands/mount/remove.rs"
      provides: "occ mount remove implementation"
      exports: ["cmd_mount_remove", "MountRemoveArgs"]
    - path: "packages/cli-rust/src/commands/mount/list.rs"
      provides: "occ mount list implementation"
      exports: ["cmd_mount_list", "MountListArgs"]
    - path: "packages/cli-rust/src/commands/start.rs"
      provides: "--mount and --no-mounts flags"
      contains: "pub mounts: Vec<String>"
  key_links:
    - from: "packages/cli-rust/src/commands/mount/add.rs"
      to: "opencode_cloud_core::config"
      via: "load_config, save_config"
      pattern: "save_config"
    - from: "packages/cli-rust/src/commands/mod.rs"
      to: "mount subcommand"
      via: "mod mount; pub use mount"
      pattern: "cmd_mount"
---

<objective>
Create the `occ mount` CLI subcommand group and add --mount/--no-mounts flags to start command.

Purpose: Provide user-facing commands to manage bind mounts in config and override them at runtime.
Output: `occ mount add/remove/list` commands working with config, `occ start --mount/--no-mounts` flags parsed (actual container integration in plan 03).
</objective>

<execution_context>
@~/.claude/get-shit-done/workflows/execute-plan.md
@~/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/17-custom-bind-mounts/17-CONTEXT.md
@.planning/phases/17-custom-bind-mounts/17-RESEARCH.md
@.planning/phases/17-custom-bind-mounts/17-01-SUMMARY.md
@packages/cli-rust/src/commands/user/mod.rs
@packages/cli-rust/src/commands/mod.rs
@packages/cli-rust/src/lib.rs
@packages/cli-rust/src/commands/start.rs
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create mount subcommand group structure</name>
  <files>packages/cli-rust/src/commands/mount/mod.rs, packages/cli-rust/src/commands/mount/add.rs, packages/cli-rust/src/commands/mount/remove.rs, packages/cli-rust/src/commands/mount/list.rs</files>
  <action>
Create `packages/cli-rust/src/commands/mount/` directory with four files.

**packages/cli-rust/src/commands/mount/mod.rs:**
Follow the user/mod.rs pattern:
```rust
//! Mount management subcommand implementations
//!
//! Provides `occ mount` subcommands for managing bind mounts.

mod add;
mod list;
mod remove;

use anyhow::Result;
use clap::{Args, Subcommand};

pub use add::cmd_mount_add;
pub use list::cmd_mount_list;
pub use remove::cmd_mount_remove;

/// Mount management command arguments
#[derive(Args)]
pub struct MountArgs {
    #[command(subcommand)]
    pub command: MountCommands,
}

/// Mount management subcommands
#[derive(Subcommand)]
pub enum MountCommands {
    /// Add a bind mount to configuration
    Add(add::MountAddArgs),
    /// Remove a bind mount from configuration
    Remove(remove::MountRemoveArgs),
    /// List configured bind mounts
    List(list::MountListArgs),
}

/// Handle mount command
pub async fn cmd_mount(args: &MountArgs, quiet: bool, verbose: u8) -> Result<()> {
    match &args.command {
        MountCommands::Add(add_args) => cmd_mount_add(add_args, quiet, verbose).await,
        MountCommands::Remove(remove_args) => cmd_mount_remove(remove_args, quiet, verbose).await,
        MountCommands::List(list_args) => cmd_mount_list(list_args, quiet, verbose).await,
    }
}
```

**packages/cli-rust/src/commands/mount/add.rs:**
```rust
//! Mount add subcommand

use anyhow::{Result, bail};
use clap::Args;
use console::style;
use opencode_cloud_core::config::{load_config, save_config};
use opencode_cloud_core::docker::{ParsedMount, check_container_path_warning, validate_mount_path};

#[derive(Args)]
pub struct MountAddArgs {
    /// Mount specification: /host/path:/container/path[:ro]
    pub mount_spec: String,

    /// Skip path validation (useful for paths that will exist later)
    #[arg(long)]
    pub no_validate: bool,

    /// Force add even if warning about system paths
    #[arg(long, short)]
    pub force: bool,
}

pub async fn cmd_mount_add(args: &MountAddArgs, quiet: bool, _verbose: u8) -> Result<()> {
    // Parse the mount spec
    let parsed = ParsedMount::parse(&args.mount_spec)?;

    // Validate host path unless --no-validate
    if !args.no_validate {
        validate_mount_path(&parsed.host_path)?;
    }

    // Check for system path warning
    if let Some(warning) = check_container_path_warning(&parsed.container_path) {
        if !args.force {
            eprintln!("{}", style(&warning).yellow());
            eprintln!();
            eprintln!("Use {} to add anyway.", style("--force").cyan());
            bail!("Mount target is a system path. Use --force to override.");
        }
        if !quiet {
            eprintln!("{}", style(&warning).yellow());
        }
    }

    // Load config and add mount
    let mut config = load_config()?;

    // Check for duplicate (by host path)
    let host_str = parsed.host_path.to_string_lossy();
    let already_exists = config.mounts.iter().any(|m| {
        ParsedMount::parse(m)
            .map(|p| p.host_path.to_string_lossy() == host_str)
            .unwrap_or(false)
    });

    if already_exists {
        if !quiet {
            println!(
                "Mount for {} already configured. Remove first with: occ mount remove {}",
                style(&host_str).cyan(),
                host_str
            );
        }
        return Ok(());
    }

    config.mounts.push(args.mount_spec.clone());
    save_config(&config)?;

    if !quiet {
        let mode = if parsed.read_only { "ro" } else { "rw" };
        println!(
            "Added mount: {} -> {} ({})",
            style(&host_str).cyan(),
            style(&parsed.container_path).cyan(),
            mode
        );
        println!();
        println!(
            "{}",
            style("Note: Restart the container for changes to take effect.").dim()
        );
    }

    Ok(())
}
```

**packages/cli-rust/src/commands/mount/remove.rs:**
```rust
//! Mount remove subcommand

use anyhow::{Result, bail};
use clap::Args;
use console::style;
use opencode_cloud_core::config::{load_config, save_config};
use opencode_cloud_core::docker::ParsedMount;

#[derive(Args)]
pub struct MountRemoveArgs {
    /// Host path of the mount to remove
    pub host_path: String,
}

pub async fn cmd_mount_remove(args: &MountRemoveArgs, quiet: bool, _verbose: u8) -> Result<()> {
    let mut config = load_config()?;

    // Find and remove mount by host path
    let original_len = config.mounts.len();
    config.mounts.retain(|m| {
        ParsedMount::parse(m)
            .map(|p| p.host_path.to_string_lossy() != args.host_path)
            .unwrap_or(true) // Keep unparseable mounts
    });

    if config.mounts.len() == original_len {
        bail!(
            "No mount found for host path: {}\n\nList mounts with: occ mount list",
            args.host_path
        );
    }

    save_config(&config)?;

    if !quiet {
        println!("Removed mount: {}", style(&args.host_path).cyan());
        println!();
        println!(
            "{}",
            style("Note: Restart the container for changes to take effect.").dim()
        );
    }

    Ok(())
}
```

**packages/cli-rust/src/commands/mount/list.rs:**
```rust
//! Mount list subcommand

use anyhow::Result;
use clap::Args;
use comfy_table::{Cell, Table, presets::UTF8_FULL_CONDENSED};
use console::style;
use opencode_cloud_core::config::load_config;
use opencode_cloud_core::docker::ParsedMount;

#[derive(Args)]
pub struct MountListArgs {
    /// Output only host paths (for scripting)
    #[arg(long)]
    pub names_only: bool,
}

pub async fn cmd_mount_list(args: &MountListArgs, quiet: bool, _verbose: u8) -> Result<()> {
    let config = load_config()?;

    if config.mounts.is_empty() {
        if !quiet && !args.names_only {
            println!("No mounts configured.");
            println!();
            println!(
                "Add a mount with: {}",
                style("occ mount add /host/path:/container/path").cyan()
            );
        }
        return Ok(());
    }

    // Names only mode for scripting
    if args.names_only {
        for mount_str in &config.mounts {
            if let Ok(parsed) = ParsedMount::parse(mount_str) {
                println!("{}", parsed.host_path.display());
            }
        }
        return Ok(());
    }

    // Table output
    let mut table = Table::new();
    table.load_preset(UTF8_FULL_CONDENSED);
    table.set_header(vec![
        Cell::new("HOST PATH"),
        Cell::new("CONTAINER PATH"),
        Cell::new("MODE"),
    ]);

    for mount_str in &config.mounts {
        match ParsedMount::parse(mount_str) {
            Ok(parsed) => {
                let mode = if parsed.read_only { "ro" } else { "rw" };
                table.add_row(vec![
                    Cell::new(parsed.host_path.display().to_string()),
                    Cell::new(&parsed.container_path),
                    Cell::new(mode),
                ]);
            }
            Err(_) => {
                // Show raw string for unparseable mounts
                table.add_row(vec![
                    Cell::new(mount_str),
                    Cell::new("(invalid)"),
                    Cell::new("-"),
                ]);
            }
        }
    }

    println!("{table}");

    Ok(())
}
```
  </action>
  <verify>
Run `cargo build -p opencode-cloud-cli` to verify compilation.
  </verify>
  <done>
Mount subcommand files exist with add, remove, list implementations. Files compile successfully.
  </done>
</task>

<task type="auto">
  <name>Task 2: Register mount subcommand and add start flags</name>
  <files>packages/cli-rust/src/commands/mod.rs, packages/cli-rust/src/lib.rs, packages/cli-rust/src/commands/start.rs</files>
  <action>
**packages/cli-rust/src/commands/mod.rs:**
Add mount module:
```rust
mod mount;
// ... existing mods ...

pub use mount::{MountArgs, cmd_mount};
// ... existing exports ...
```

**packages/cli-rust/src/lib.rs:**
Add Mount variant to Commands enum (after User):
```rust
/// Manage bind mounts
Mount(commands::MountArgs),
```

Add match arm in main command handler (after User):
```rust
Commands::Mount(args) => commands::cmd_mount(args, cli.quiet, cli.verbose).await,
```

**packages/cli-rust/src/commands/start.rs:**
Add these fields to StartArgs struct (after `no_update_check`):
```rust
/// Add one-time bind mount (can be specified multiple times)
/// Format: /host/path:/container/path[:ro]
#[arg(long = "mount", action = clap::ArgAction::Append)]
pub mounts: Vec<String>,

/// Skip configured mounts (only use --mount flags if specified)
#[arg(long)]
pub no_mounts: bool,
```

Note: The actual usage of these flags in container creation will be implemented in plan 03. For now, just add the argument parsing.
  </action>
  <verify>
Run `cargo build -p opencode-cloud-cli` to verify compilation.
Run `cargo run -p opencode-cloud-cli -- mount --help` to verify subcommand is registered.
Run `cargo run -p opencode-cloud-cli -- start --help` to verify --mount and --no-mounts flags appear.
  </verify>
  <done>
Mount subcommand registered in CLI. `occ mount --help` shows add/remove/list. `occ start --help` shows --mount and --no-mounts flags.
  </done>
</task>

</tasks>

<verification>
1. `cargo build --all-targets --all-features` passes
2. `cargo test --all-features` passes
3. `cargo clippy --all-targets --all-features -- -D warnings` passes
4. `occ mount --help` shows add, remove, list subcommands
5. `occ mount add --help` shows mount_spec argument and --no-validate, --force flags
6. `occ mount remove --help` shows host_path argument
7. `occ mount list --help` shows --names-only flag
8. `occ start --help` shows --mount and --no-mounts flags
</verification>

<success_criteria>
- All mount subcommands are accessible via CLI
- `occ mount add /host:/container` adds mount to config
- `occ mount remove /host` removes mount from config
- `occ mount list` shows configured mounts in table format
- start command accepts --mount and --no-mounts flags (container integration in next plan)
</success_criteria>

<output>
After completion, create `.planning/phases/17-custom-bind-mounts/17-02-SUMMARY.md`
</output>
