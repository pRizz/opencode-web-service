---
phase: 17-custom-bind-mounts
plan: 03
type: execute
wave: 3
depends_on: ["17-01", "17-02"]
files_modified:
  - packages/core/src/docker/container.rs
  - packages/core/src/docker/mod.rs
  - packages/cli-rust/src/commands/start.rs
  - packages/cli-rust/src/commands/status.rs
autonomous: true

must_haves:
  truths:
    - "Container starts with configured bind mounts applied"
    - "Container starts with CLI --mount mounts applied"
    - "CLI mounts are additive to config mounts"
    - "--no-mounts skips config mounts"
    - "Status command shows active bind mounts section"
    - "Invalid mount paths at start time show clear error"
  artifacts:
    - path: "packages/core/src/docker/container.rs"
      provides: "create_container with bind mounts parameter"
      contains: "bind_mounts: Option<Vec<ParsedMount>>"
    - path: "packages/cli-rust/src/commands/status.rs"
      provides: "Mounts section in status output"
      contains: "display_mounts_section"
  key_links:
    - from: "packages/cli-rust/src/commands/start.rs"
      to: "packages/core/src/docker/container.rs"
      via: "create_container call with bind_mounts"
      pattern: "setup_and_start.*bind_mounts"
    - from: "packages/cli-rust/src/commands/status.rs"
      to: "container inspect mounts"
      via: "inspect_container().host_config.mounts"
      pattern: "MountTypeEnum::BIND"
---

<objective>
Integrate bind mounts into container creation and display active mounts in status.

Purpose: Complete the bind mount feature by applying mounts when containers start and showing them in status.
Output: Containers start with bind mounts from config and CLI flags. Status shows active bind mounts.
</objective>

<execution_context>
@~/.claude/get-shit-done/workflows/execute-plan.md
@~/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/17-custom-bind-mounts/17-CONTEXT.md
@.planning/phases/17-custom-bind-mounts/17-RESEARCH.md
@.planning/phases/17-custom-bind-mounts/17-01-SUMMARY.md
@.planning/phases/17-custom-bind-mounts/17-02-SUMMARY.md
@packages/core/src/docker/container.rs
@packages/core/src/docker/mod.rs
@packages/cli-rust/src/commands/start.rs
@packages/cli-rust/src/commands/status.rs
</context>

<tasks>

<task type="auto">
  <name>Task 1: Add bind mounts parameter to container creation</name>
  <files>packages/core/src/docker/container.rs, packages/core/src/docker/mod.rs</files>
  <action>
**packages/core/src/docker/container.rs:**

1. Add import at top:
   ```rust
   use super::mount::ParsedMount;
   ```

2. Update `create_container` function signature to add `bind_mounts` parameter:
   ```rust
   #[allow(clippy::too_many_arguments)]
   pub async fn create_container(
       client: &DockerClient,
       name: Option<&str>,
       image: Option<&str>,
       opencode_web_port: Option<u16>,
       env_vars: Option<Vec<String>>,
       bind_address: Option<&str>,
       cockpit_port: Option<u16>,
       cockpit_enabled: Option<bool>,
       bind_mounts: Option<Vec<ParsedMount>>,  // NEW PARAMETER
   ) -> Result<String, DockerError> {
   ```

3. After creating the volume mounts vec (around line 84-106), add bind mounts:
   ```rust
   // Add bind mounts from config/CLI
   if let Some(ref user_mounts) = bind_mounts {
       for parsed in user_mounts {
           mounts.push(parsed.to_bollard_mount());
       }
   }
   ```

**packages/core/src/docker/mod.rs:**

1. Update `setup_and_start` function signature to accept bind_mounts:
   ```rust
   pub async fn setup_and_start(
       client: &DockerClient,
       opencode_web_port: Option<u16>,
       env_vars: Option<Vec<String>>,
       bind_address: Option<&str>,
       cockpit_port: Option<u16>,
       cockpit_enabled: Option<bool>,
       bind_mounts: Option<Vec<ParsedMount>>,  // NEW PARAMETER
   ) -> Result<String, DockerError> {
   ```

2. Pass bind_mounts to `create_container` call:
   ```rust
   container::create_container(
       client,
       None,
       None,
       opencode_web_port,
       env_vars,
       bind_address,
       cockpit_port,
       cockpit_enabled,
       bind_mounts,  // NEW
   )
   .await?
   ```
  </action>
  <verify>
Run `cargo build -p opencode-cloud-core` to verify compilation.
  </verify>
  <done>
create_container and setup_and_start accept bind_mounts parameter. Bind mounts are added to container's mount vector.
  </done>
</task>

<task type="auto">
  <name>Task 2: Wire start command to pass bind mounts to container</name>
  <files>packages/cli-rust/src/commands/start.rs</files>
  <action>
In `packages/cli-rust/src/commands/start.rs`:

1. Add imports at top:
   ```rust
   use opencode_cloud_core::docker::{ParsedMount, validate_mount_path, check_container_path_warning};
   ```

2. Create a helper function to collect and validate mounts (add before `cmd_start`):
   ```rust
   /// Collect and validate bind mounts from config and CLI flags
   fn collect_bind_mounts(
       config: &opencode_cloud_core::Config,
       cli_mounts: &[String],
       no_mounts: bool,
       quiet: bool,
   ) -> Result<Vec<ParsedMount>> {
       let mut all_mounts = Vec::new();

       // Add config mounts unless --no-mounts
       if !no_mounts {
           for mount_str in &config.mounts {
               let parsed = ParsedMount::parse(mount_str)
                   .map_err(|e| anyhow!("Invalid config mount '{}': {}", mount_str, e))?;
               all_mounts.push(parsed);
           }
       }

       // Add CLI mounts (always, even with --no-mounts)
       for mount_str in cli_mounts {
           let parsed = ParsedMount::parse(mount_str)
               .map_err(|e| anyhow!("Invalid mount '{}': {}", mount_str, e))?;
           all_mounts.push(parsed);
       }

       // Validate all mount paths exist
       for parsed in &all_mounts {
           if let Err(e) = validate_mount_path(&parsed.host_path) {
               return Err(anyhow!(
                   "Mount path validation failed for '{}':\n  {}\n\nDid the directory move? Run: occ mount remove {}",
                   parsed.host_path.display(),
                   e,
                   parsed.host_path.display()
               ));
           }

           // Show warnings for system paths (non-blocking)
           if !quiet {
               if let Some(warning) = check_container_path_warning(&parsed.container_path) {
                   eprintln!("{}", style(&warning).yellow());
               }
           }
       }

       Ok(all_mounts)
   }
   ```

3. In `cmd_start`, after loading config and before security checks, collect mounts:
   ```rust
   // Collect and validate bind mounts
   let bind_mounts = collect_bind_mounts(&config, &args.mounts, args.no_mounts, quiet)?;
   let bind_mounts_option = if bind_mounts.is_empty() {
       None
   } else {
       Some(bind_mounts)
   };
   ```

4. Update the `start_container` helper function signature:
   ```rust
   async fn start_container(
       client: &DockerClient,
       port: u16,
       bind_address: &str,
       cockpit_port: u16,
       cockpit_enabled: bool,
       bind_mounts: Option<Vec<ParsedMount>>,
   ) -> Result<String, DockerError> {
       setup_and_start(
           client,
           Some(port),
           None,
           Some(bind_address),
           Some(cockpit_port),
           Some(cockpit_enabled),
           bind_mounts,
       )
       .await
   }
   ```

5. Update the call to `start_container` in `cmd_start`:
   ```rust
   let container_id = match start_container(
       &client,
       port,
       bind_addr,
       config.cockpit_port,
       config.cockpit_enabled,
       bind_mounts_option,
   )
   .await
   ```

6. After starting, if mounts were applied and not quiet, show summary:
   ```rust
   // Show mount summary if any mounts were applied
   if !quiet && !args.mounts.is_empty() {
       println!();
       println!("{}", style("Mounts applied:").dim());
       for m in &args.mounts {
           if let Ok(p) = ParsedMount::parse(m) {
               let mode = if p.read_only { "ro" } else { "rw" };
               println!("  {} -> {} ({})", p.host_path.display(), p.container_path, mode);
           }
       }
   }
   ```
  </action>
  <verify>
Run `cargo build -p opencode-cloud-cli` to verify compilation.
  </verify>
  <done>
start command collects mounts from config and CLI, validates paths, and passes to container creation. Compilation succeeds.
  </done>
</task>

<task type="auto">
  <name>Task 3: Add Mounts section to status command</name>
  <files>packages/cli-rust/src/commands/status.rs</files>
  <action>
In `packages/cli-rust/src/commands/status.rs`:

1. Add import:
   ```rust
   use opencode_cloud_core::bollard::service::MountTypeEnum;
   ```

2. Create helper function to display mounts section (add before `display_security_section`):
   ```rust
   /// Display the Mounts section of status output
   fn display_mounts_section(
       mounts: &[opencode_cloud_core::bollard::service::Mount],
       config_mounts: &[String],
   ) {
       // Filter to only bind mounts (not volumes)
       let bind_mounts: Vec<_> = mounts
           .iter()
           .filter(|m| m.typ == Some(MountTypeEnum::BIND))
           .collect();

       if bind_mounts.is_empty() {
           return;
       }

       println!();
       println!("{}", style("Mounts").bold());
       println!("{}", style("------").dim());

       // Create a set of config mount sources for source detection
       let config_sources: std::collections::HashSet<String> = config_mounts
           .iter()
           .filter_map(|m| {
               opencode_cloud_core::docker::ParsedMount::parse(m)
                   .ok()
                   .map(|p| p.host_path.to_string_lossy().to_string())
           })
           .collect();

       for mount in bind_mounts {
           let source = mount.source.as_deref().unwrap_or("unknown");
           let target = mount.target.as_deref().unwrap_or("unknown");
           let mode = if mount.read_only.unwrap_or(false) {
               "ro"
           } else {
               "rw"
           };

           // Determine if this mount came from config or CLI
           let source_tag = if config_sources.contains(source) {
               style("(config)").dim()
           } else {
               style("(cli)").cyan()
           };

           println!(
               "  {} -> {} {} {}",
               style(source).cyan(),
               target,
               style(mode).dim(),
               source_tag
           );
       }
   }
   ```

3. In `cmd_status`, after extracting container info and before showing security section, add mounts display.

   First, extract mounts from container inspect (after the `host_port` extraction around line 111-120):
   ```rust
   // Extract bind mounts from container
   let container_mounts = info
       .host_config
       .as_ref()
       .and_then(|hc| hc.mounts.clone())
       .unwrap_or_default();
   ```

4. After the "Installed" section (around line 305-307), before the Security section, add:
   ```rust
   // Show Mounts section if container has bind mounts
   if running {
       display_mounts_section(&container_mounts, &config.as_ref().map(|c| c.mounts.clone()).unwrap_or_default());
   }
   ```
  </action>
  <verify>
Run `cargo build -p opencode-cloud-cli` to verify compilation.
Run `cargo clippy -p opencode-cloud-cli -- -D warnings` to verify no warnings.
  </verify>
  <done>
Status command displays Mounts section showing active bind mounts with source (config/cli) indicators.
  </done>
</task>

</tasks>

<verification>
1. `cargo build --all-targets --all-features` passes
2. `cargo test --all-features` passes
3. `cargo clippy --all-targets --all-features -- -D warnings` passes
4. `just fmt && just lint && just test && just build` all pass
5. Manual test: `occ mount add /tmp:/mnt/tmp` then `occ start` - verify mount appears
6. Manual test: `occ status` shows Mounts section with the configured mount
7. Manual test: `occ start --mount /tmp:/mnt/test` adds one-time mount
8. Manual test: `occ start --no-mounts` skips config mounts
9. Manual test: Invalid path at start time shows clear error with fix suggestion
</verification>

<success_criteria>
- Container creation applies bind mounts from both config and CLI
- Status shows Mounts section with source indicators (config/cli)
- Invalid paths at start time produce clear error messages with fix suggestions
- --no-mounts flag prevents config mounts from being applied
- CLI mounts are additive (work with or without config mounts)
</success_criteria>

<output>
After completion, create `.planning/phases/17-custom-bind-mounts/17-03-SUMMARY.md`
</output>
