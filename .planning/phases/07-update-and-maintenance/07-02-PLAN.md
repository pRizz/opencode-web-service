---
phase: 07-update-and-maintenance
plan: 02
type: execute
wave: 1
depends_on: []
files_modified:
  - packages/core/src/docker/health.rs
  - packages/core/src/docker/mod.rs
  - packages/core/src/config/validation.rs
  - packages/core/src/config/mod.rs
  - packages/core/src/config/schema.rs
  - packages/core/Cargo.toml
  - packages/cli-rust/src/commands/start.rs
  - packages/cli-rust/src/commands/status.rs
autonomous: true

must_haves:
  truths:
    - "Health check returns 200 when service is healthy"
    - "Health check returns service version in response"
    - "Config validation catches invalid port values"
    - "Config validation provides fix command for each error"
    - "Start command validates config before starting"
  artifacts:
    - path: "packages/core/src/docker/health.rs"
      provides: "Health check via OpenCode's /global/health"
      exports: ["check_health", "HealthResponse", "HealthError"]
    - path: "packages/core/src/config/validation.rs"
      provides: "Config validation with actionable errors"
      exports: ["ValidationError", "ValidationWarning", "validate_config"]
  key_links:
    - from: "packages/cli-rust/src/commands/status.rs"
      to: "packages/core/src/docker/health.rs"
      via: "calls check_health"
      pattern: "check_health\\("
    - from: "packages/cli-rust/src/commands/start.rs"
      to: "packages/core/src/config/validation.rs"
      via: "calls validate_config"
      pattern: "validate_config\\("
---

<objective>
Implement health check endpoint integration and config validation with actionable error messages.

Purpose: Monitoring tools (AWS ALB, uptime monitors) can verify service health; users get clear feedback when config is invalid with exact commands to fix issues.
Output: Health check module, config validation module, and integration into status and start commands.
</objective>

<execution_context>
@~/.claude/get-shit-done/workflows/execute-plan.md
@~/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/07-update-and-maintenance/07-CONTEXT.md
@.planning/phases/07-update-and-maintenance/07-RESEARCH.md

# Relevant source files
@packages/core/src/docker/mod.rs
@packages/core/src/config/schema.rs
@packages/cli-rust/src/commands/start.rs
@packages/cli-rust/src/commands/status.rs
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create health check module</name>
  <files>
    packages/core/src/docker/health.rs
    packages/core/src/docker/mod.rs
    packages/core/Cargo.toml
  </files>
  <action>
Add reqwest dependency to `packages/core/Cargo.toml`:
- Add `reqwest = { version = "0.12", features = ["json"] }` to dependencies

Create `packages/core/src/docker/health.rs`:

1. Define `HealthResponse` struct (derive Deserialize, Serialize, Debug, Clone):
   - `healthy: bool`
   - `version: String`

2. Define `ExtendedHealthResponse` struct for CLI display (derive Serialize, Debug):
   - `healthy: bool`
   - `version: String`
   - `container_state: String`
   - `uptime_seconds: u64`
   - `memory_usage_mb: Option<u64>` (skip_serializing_if None)

3. Define `HealthError` enum (derive Debug, thiserror::Error):
   - `#[error("Request failed: {0}")]` RequestError(#[from] reqwest::Error)
   - `#[error("Service unhealthy (HTTP {0})")]` Unhealthy(u16)
   - `#[error("Connection refused - service may not be running")]` ConnectionRefused
   - `#[error("Timeout - service may be starting")]` Timeout

4. Implement `check_health(port: u16) -> Result<HealthResponse, HealthError>`:
   - Build URL: `http://127.0.0.1:{port}/global/health`
   - Use reqwest::Client with 5 second timeout
   - Handle connection refused -> `HealthError::ConnectionRefused`
   - Handle timeout -> `HealthError::Timeout`
   - Return `HealthResponse` on 200 OK
   - Return `HealthError::Unhealthy(status)` on non-200

5. Implement `check_health_extended(client: &DockerClient, port: u16) -> Result<ExtendedHealthResponse, HealthError>`:
   - Call `check_health(port)` for basic info
   - Get container stats via bollard for uptime and memory
   - Combine into ExtendedHealthResponse
   - If container stats fail, still return response with container_state = "unknown"

Update `packages/core/src/docker/mod.rs`:
- Add `mod health;`
- Export: `pub use health::{check_health, check_health_extended, HealthResponse, ExtendedHealthResponse, HealthError};`
  </action>
  <verify>
Run `just build` - health.rs compiles.
Run `cargo doc --package opencode-cloud-core` - health module docs generate.
  </verify>
  <done>
Health module exports `check_health`, `check_health_extended`, `HealthResponse`, `ExtendedHealthResponse`, and `HealthError`.
Uses reqwest to query OpenCode's /global/health endpoint.
  </done>
</task>

<task type="auto">
  <name>Task 2: Create config validation module</name>
  <files>
    packages/core/src/config/validation.rs
    packages/core/src/config/mod.rs
    packages/core/src/config/schema.rs
  </files>
  <action>
Create `packages/core/src/config/validation.rs`:

1. Define `ValidationError` struct (derive Debug, Clone):
   - `field: String` - Config field name
   - `message: String` - What's wrong
   - `fix_command: String` - Exact occ command to fix it

2. Define `ValidationWarning` struct (derive Debug, Clone):
   - `field: String`
   - `message: String`
   - `fix_command: String`

3. Implement `validate_config(config: &Config) -> Result<Vec<ValidationWarning>, ValidationError>`:
   Returns first error encountered (stop at first error per CONTEXT.md), or Ok with warnings list.

   Validation rules (in order):

   a. Port validation:
      - If port < 1024: Error "Port must be >= 1024 (non-privileged)"
        Fix: "occ config set opencode_web_port 3000"
      - If port > 65535: Error "Port must be <= 65535"
        Fix: "occ config set opencode_web_port 3000"

   b. Bind address validation:
      - Call `validate_bind_address(&config.bind_address)`
      - If Err: Error with message from validation
        Fix: "occ config set bind_address 127.0.0.1"

   c. Boot mode validation:
      - If not "user" or "system": Error "boot_mode must be 'user' or 'system'"
        Fix: "occ config set boot_mode user"

   d. Rate limit validation:
      - If rate_limit_attempts == 0: Error "rate_limit_attempts must be > 0"
        Fix: "occ config set rate_limit_attempts 5"
      - If rate_limit_window_seconds == 0: Error "rate_limit_window_seconds must be > 0"
        Fix: "occ config set rate_limit_window_seconds 60"

   Warnings (non-fatal):

   a. Network exposure without auth:
      - If `is_network_exposed() && users.is_empty() && !allow_unauthenticated_network`:
        Warning "Network exposed without authentication"
        Fix: "occ user add"

   b. Legacy auth fields present:
      - If auth_username or auth_password is Some and non-empty:
        Warning "Legacy auth fields present; consider using 'occ user add' instead"
        Fix: "occ config set auth_username ''"

4. Implement `display_validation_error(error: &ValidationError)`:
   - Print styled error using console crate
   - Format:
     ```
     Error: Configuration error

       Field:   {field}
       Problem: {message}

     To fix, run:
       {fix_command}
     ```

5. Implement `display_validation_warning(warning: &ValidationWarning)`:
   - Print styled warning (yellow)
   - Similar format but with "Warning:" prefix

Update `packages/core/src/config/mod.rs`:
- Add `mod validation;`
- Export: `pub use validation::{ValidationError, ValidationWarning, validate_config, display_validation_error, display_validation_warning};`

Note: Import `validate_bind_address` from schema.rs and re-export if needed.
  </action>
  <verify>
Run `just build` - validation.rs compiles.
Run `just test` - existing config tests pass.
  </verify>
  <done>
Validation module exports `ValidationError`, `ValidationWarning`, `validate_config`, `display_validation_error`, `display_validation_warning`.
Validates port, bind_address, boot_mode, rate_limit fields.
Returns actionable fix commands for each error.
  </done>
</task>

<task type="auto">
  <name>Task 3: Integrate health and validation into CLI commands</name>
  <files>
    packages/cli-rust/src/commands/start.rs
    packages/cli-rust/src/commands/status.rs
  </files>
  <action>
Update `packages/cli-rust/src/commands/start.rs`:

1. At the beginning of `cmd_start` (after loading config), add validation:
   ```rust
   // Validate config before starting
   match validate_config(&config) {
       Ok(warnings) => {
           for warning in warnings {
               display_validation_warning(&warning);
           }
       }
       Err(error) => {
           display_validation_error(&error);
           return Err(anyhow::anyhow!("Configuration invalid. Fix the error above and try again."));
       }
   }
   ```

2. Import from opencode_cloud_core::config:
   - `validate_config`, `display_validation_error`, `display_validation_warning`

Update `packages/cli-rust/src/commands/status.rs`:

1. Add health check to status output when container is running:
   - After displaying container state, if running:
     - Call `check_health(config.opencode_web_port)`
     - On success: Show "Health: Healthy (v{version})" in green
     - On ConnectionRefused: Show "Health: Service starting..." in yellow
     - On Timeout: Show "Health: Service starting..." in yellow
     - On Unhealthy: Show "Health: Unhealthy (HTTP {code})" in red
     - On other error: Show "Health: Check failed" in yellow

2. Import from opencode_cloud_core::docker:
   - `check_health`, `HealthError`

3. Add the health status line in the Status section, after the State line:
   ```
   Status
     State:      Running (up 2h 15m)
     Health:     Healthy (v0.43.1)
     Container:  opencode-cloud
   ```
  </action>
  <verify>
Run `just build` - CLI compiles.
Run `just lint` - no new lint warnings.
Run `occ status` (with running container) - shows Health line.
  </verify>
  <done>
Start command validates config before starting, displays errors/warnings.
Status command shows health check result when container is running.
Invalid config prevents service start with actionable fix command.
  </done>
</task>

</tasks>

<verification>
1. `just build` passes with no errors
2. `just test` passes
3. `just lint` passes
4. `occ status` (with running container) shows Health line
5. Test validation: Temporarily set invalid port, try `occ start`, see error with fix command
</verification>

<success_criteria>
- Health check queries OpenCode's /global/health endpoint
- Status shows health status when container running
- Config validation runs before service start
- Validation errors show exact occ command to fix
- Warnings display but don't block start
</success_criteria>

<output>
After completion, create `.planning/phases/07-update-and-maintenance/07-02-SUMMARY.md`
</output>
