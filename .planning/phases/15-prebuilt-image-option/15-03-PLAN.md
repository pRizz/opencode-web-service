---
phase: 15-prebuilt-image-option
plan: 03
type: execute
wave: 2
depends_on: ["15-01"]
files_modified:
  - packages/cli-rust/src/wizard/mod.rs
  - packages/cli-rust/src/commands/update.rs
  - packages/cli-rust/src/commands/status.rs
autonomous: true

must_haves:
  truths:
    - "Setup wizard prompts for image source preference"
    - "occ update respects image_source config (pulls if prebuilt, builds if build)"
    - "occ status shows image provenance (source and registry)"
    - "Update command shows clear message about what action it will take"
  artifacts:
    - path: "packages/cli-rust/src/wizard/mod.rs"
      provides: "Image source prompt in wizard flow"
      contains: "image_source"
    - path: "packages/cli-rust/src/commands/update.rs"
      provides: "Respect image_source when updating"
      contains: "image_source"
    - path: "packages/cli-rust/src/commands/status.rs"
      provides: "Display image provenance"
      contains: "load_state"
  key_links:
    - from: "packages/cli-rust/src/wizard/mod.rs"
      to: "packages/core/src/config/schema.rs"
      via: "WizardState applies image_source to Config"
      pattern: "image_source"
    - from: "packages/cli-rust/src/commands/update.rs"
      to: "packages/core/src/docker/image.rs"
      via: "pull_image or build_image based on config"
      pattern: "image_source.*prebuilt|build_image"
    - from: "packages/cli-rust/src/commands/status.rs"
      to: "packages/core/src/docker/state.rs"
      via: "load_state for provenance display"
      pattern: "load_state"
---

<objective>
Integrate image source preference into wizard, update command, and status display.

Purpose: Complete the user experience by letting users set preference in wizard, having update respect that preference, and showing provenance in status.

Output: Wizard with image source prompt, update command that respects config, status showing provenance.
</objective>

<execution_context>
@~/.claude/get-shit-done/workflows/execute-plan.md
@~/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/15-prebuilt-image-option/15-CONTEXT.md
@.planning/phases/15-prebuilt-image-option/15-RESEARCH.md
@.planning/phases/15-prebuilt-image-option/15-01-SUMMARY.md
@packages/cli-rust/src/wizard/mod.rs
@packages/cli-rust/src/commands/update.rs
@packages/cli-rust/src/commands/status.rs
</context>

<tasks>

<task type="auto">
  <name>Task 1: Add image source prompt to setup wizard</name>
  <files>packages/cli-rust/src/wizard/mod.rs</files>
  <action>
1. Update WizardState struct to include image_source:
```rust
/// Wizard state holding collected configuration values
#[derive(Debug, Clone)]
pub struct WizardState {
    /// Username for authentication
    pub auth_username: Option<String>,
    /// Password for authentication
    pub auth_password: Option<String>,
    /// Port for the web UI
    pub port: u16,
    /// Bind address (localhost or 0.0.0.0)
    pub bind: String,
    /// Image source preference: "prebuilt" or "build"
    pub image_source: String,
}
```

2. Update apply_to_config to include image_source:
```rust
impl WizardState {
    /// Apply wizard state to a Config struct
    pub fn apply_to_config(&self, config: &mut Config) {
        if let Some(ref username) = self.auth_username {
            config.auth_username = Some(username.clone());
        }
        if let Some(ref password) = self.auth_password {
            config.auth_password = Some(password.clone());
        }
        config.opencode_web_port = self.port;
        config.bind = self.bind.clone();
        config.image_source = self.image_source.clone();
    }
}
```

3. Add image source prompt function (new helper in mod.rs or separate file):
```rust
/// Prompt user to choose image source
fn prompt_image_source(step: u8, total: u8) -> Result<String> {
    println!("{}", style(format!("Step {step}/{total}: Image Source")).cyan().bold());
    println!();
    println!("How would you like to get the Docker image?");
    println!();
    println!("  {} Pull prebuilt image (~2 minutes)", style("[1]").bold());
    println!("      Download from GitHub Container Registry");
    println!("      Fast, verified builds published automatically");
    println!();
    println!("  {} Build from source (30-60 minutes)", style("[2]").bold());
    println!("      Compile everything locally");
    println!("      Full transparency, customizable Dockerfile");
    println!();
    println!("{}", style("Build history: https://github.com/pRizz/opencode-cloud/actions").dim());
    println!();

    let options = vec![
        "Pull prebuilt image (recommended)",
        "Build from source",
    ];

    let selection = dialoguer::Select::new()
        .with_prompt("Select image source")
        .items(&options)
        .default(0)
        .interact()
        .map_err(|_| handle_interrupt())?;

    println!();

    Ok(if selection == 0 { "prebuilt" } else { "build" }.to_string())
}
```

4. Update run_wizard to include image source prompt after auth:
- Change total_steps calculation to account for new step
- Add image_source prompt after auth prompt (before port/bind)
- For quick setup, default to "prebuilt"

```rust
// 4. Collect values
let total_steps = if quick { 2 } else { 4 };  // Was 1 and 3

let (username, password) = prompt_auth(1, total_steps)?;
let image_source = prompt_image_source(2, total_steps)?;

let (port, bind) = if quick {
    (3000, "localhost".to_string())
} else {
    let port = prompt_port(3, total_steps, 3000)?;
    let bind = prompt_hostname(4, total_steps, "localhost")?;
    (port, bind)
};

let state = WizardState {
    auth_username: Some(username.clone()),
    auth_password: Some(password.clone()),
    port,
    bind,
    image_source,
};
```

For quick setup mode, still prompt for image source (it's important enough to ask):
```rust
let total_steps = if quick { 2 } else { 4 };

let (username, password) = prompt_auth(1, total_steps)?;
let image_source = prompt_image_source(2, total_steps)?;

let (port, bind) = if quick {
    (3000, "localhost".to_string())
} else {
    let port = prompt_port(3, total_steps, 3000)?;
    let bind = prompt_hostname(4, total_steps, "localhost")?;
    (port, bind)
};
```

5. Update summary display to show image source (in summary.rs or summary function):
```rust
// In display_summary function, add:
println!("  Image:    {} {}",
    state.image_source,
    if state.image_source == "prebuilt" { "(~2 min download)" } else { "(30-60 min build)" }
);
```

6. Update tests to include image_source field:
```rust
#[test]
fn test_wizard_state_apply_to_config() {
    let state = WizardState {
        auth_username: Some("testuser".to_string()),
        auth_password: Some("testpass".to_string()),
        port: 8080,
        bind: "0.0.0.0".to_string(),
        image_source: "prebuilt".to_string(),
    };

    let mut config = Config::default();
    state.apply_to_config(&mut config);

    assert_eq!(config.auth_username, Some("testuser".to_string()));
    assert_eq!(config.auth_password, Some("testpass".to_string()));
    assert_eq!(config.opencode_web_port, 8080);
    assert_eq!(config.bind, "0.0.0.0");
    assert_eq!(config.image_source, "prebuilt");
}
```
  </action>
  <verify>Run `just test` - wizard tests pass with updated struct</verify>
  <done>Setup wizard prompts for image source and saves to config</done>
</task>

<task type="auto">
  <name>Task 2: Update command respects image_source config</name>
  <files>packages/cli-rust/src/commands/update.rs</files>
  <action>
1. Add imports:
```rust
use opencode_cloud_core::docker::{
    // ... existing imports ...
    build_image, pull_image, save_state, ImageState, IMAGE_TAG_DEFAULT,
};
```

2. Update handle_update function to check config.image_source and branch accordingly:

Replace the current step 2 (update_image call) with branching logic:
```rust
// Step 2: Get new image based on config.image_source
if verbose > 0 {
    eprintln!("{} Getting new image...", style("[2/5]").cyan());
}

if config.image_source == "prebuilt" {
    // Pull prebuilt image
    if !quiet {
        println!();
        println!("{}", style("Pulling prebuilt image from registry...").cyan());
        println!("{}", style("(Using prebuilt per config. Change with: occ config set image_source build)").dim());
        println!();
    }

    let mut progress = if quiet {
        ProgressReporter::new()
    } else {
        ProgressReporter::with_context("Pulling image")
    };

    let full_image = pull_image(client, Some(IMAGE_TAG_DEFAULT), &mut progress)
        .await
        .map_err(|e| anyhow!("Failed to pull image: {e}"))?;

    // Determine registry from image name
    let registry = if full_image.starts_with("ghcr.io") {
        "ghcr.io"
    } else {
        "docker.io"
    };

    // Save provenance
    save_state(&ImageState::prebuilt(
        opencode_cloud_core::docker::get_cli_version(),
        registry,
    ))
    .ok();
} else {
    // Build from source
    if !quiet {
        println!();
        println!("{}", style("Building image from source...").cyan());
        println!("{}", style("(Using build per config. Change with: occ config set image_source prebuilt)").dim());
        println!();
    }

    let mut progress = if quiet {
        ProgressReporter::new()
    } else {
        ProgressReporter::with_context("Building image")
    };

    build_image(client, Some(IMAGE_TAG_DEFAULT), &mut progress, false)
        .await
        .map_err(|e| anyhow!("Failed to build image: {e}"))?;

    // Save provenance
    save_state(&ImageState::built(
        opencode_cloud_core::docker::get_cli_version(),
    ))
    .ok();
}
```

Note: The existing `update_image` function does backup + pull. We need to do backup separately, then branch on pull vs build. Check if there's a separate backup function or inline the backup logic before the branch.

Looking at the update flow, we need to:
1. Back up current image (tag as "previous")
2. Either pull or build new image

If update_image combines both, we may need to either:
- Call backup_image separately, then pull_image or build_image
- Or add a new function that does backup + appropriate action

For simplicity, keep the existing backup logic from update_image (extract if needed) and just replace the pull with conditional pull/build.

Actually, looking at the imports, `update_image` is in opencode_cloud_core::docker. Let's keep using it for prebuilt (it already does backup + pull), but add a parallel path for build:

```rust
// Step 2: Get new image based on config.image_source
if verbose > 0 {
    eprintln!("{} Getting new image...", style("[2/5]").cyan());
}

if config.image_source == "build" {
    // Building from source
    if !quiet {
        println!();
        println!(
            "{} Rebuilding image from source (per config.image_source=build)",
            style("Info:").cyan()
        );
        println!(
            "{}",
            style("To use prebuilt images: occ config set image_source prebuilt").dim()
        );
        println!();
    }

    // First, tag current as previous for rollback (same as update_image does)
    // Use the tag_image function if available, or do it inline
    let _ = tag_current_as_previous(client).await; // Helper function

    // Then build new image
    let mut progress = if quiet {
        ProgressReporter::new()
    } else {
        ProgressReporter::with_context("Building image")
    };

    build_image(client, Some(IMAGE_TAG_DEFAULT), &mut progress, false)
        .await
        .map_err(|e| anyhow!("Failed to build image: {e}"))?;

    // Save provenance
    save_state(&ImageState::built(
        opencode_cloud_core::docker::get_cli_version(),
    ))
    .ok();
} else {
    // Pulling prebuilt (default)
    if !quiet {
        println!();
        println!(
            "{} Pulling prebuilt image (per config.image_source=prebuilt)",
            style("Info:").cyan()
        );
        println!(
            "{}",
            style("To build from source: occ config set image_source build").dim()
        );
        println!();
    }

    let mut progress = if quiet {
        ProgressReporter::new()
    } else {
        ProgressReporter::with_context("Updating image")
    };

    let full_image = update_image(client, &mut progress)
        .await
        .map_err(|e| anyhow!("Failed to update image: {e}"))?;

    // Determine registry and save provenance
    let registry = if full_image.starts_with("ghcr.io") {
        "ghcr.io"
    } else {
        "docker.io"
    };
    save_state(&ImageState::prebuilt(
        opencode_cloud_core::docker::get_cli_version(),
        registry,
    ))
    .ok();
}
```

For the tag_current_as_previous helper, check if there's an existing function in docker module. If not, add a simple helper that does what update_image does for backup:
```rust
/// Tag current image as previous for rollback support
async fn tag_current_as_previous(client: &DockerClient) -> Result<()> {
    use opencode_cloud_core::docker::{IMAGE_NAME_GHCR, IMAGE_TAG_DEFAULT};

    let current = format!("{IMAGE_NAME_GHCR}:{IMAGE_TAG_DEFAULT}");
    let previous = format!("{IMAGE_NAME_GHCR}:previous");

    // Check if current exists
    if !opencode_cloud_core::docker::image_exists(client, IMAGE_NAME_GHCR, IMAGE_TAG_DEFAULT).await? {
        return Ok(()); // Nothing to back up
    }

    // Tag current as previous
    use opencode_cloud_core::bollard::image::TagImageOptions;
    client
        .inner()
        .tag_image(
            &current,
            Some(TagImageOptions {
                repo: IMAGE_NAME_GHCR,
                tag: "previous",
            }),
        )
        .await
        .ok(); // Ignore errors

    Ok(())
}
```

3. Add import for IMAGE_NAME_GHCR if needed.
  </action>
  <verify>
1. `just fmt && just lint` - Code is clean
2. `just test` - Tests pass
3. `just build` - Builds successfully
  </verify>
  <done>Update command respects image_source config with clear messaging</done>
</task>

<task type="auto">
  <name>Task 3: Status command shows image provenance</name>
  <files>packages/cli-rust/src/commands/status.rs</files>
  <action>
1. Add import for image state:
```rust
use opencode_cloud_core::docker::load_state;
```

2. After showing image version, add provenance display:

Find the section that shows "Image: ..." and "Image ver: ..." and add provenance info:

```rust
// Show image info with provenance
println!("Image:       {image}");

// Show CLI and image versions
let cli_version = get_cli_version();
println!("CLI:         v{cli_version}");

// Try to get image version from label
if let Ok(Some(img_version)) = get_image_version(&client, &image).await {
    if img_version != "dev" {
        if cli_version == img_version {
            println!("Image ver:   v{img_version}");
        } else {
            println!(
                "Image ver:   v{} {}",
                img_version,
                style("(differs from CLI)").yellow().dim()
            );
        }
    }
}

// Show image provenance from state file
if let Some(state) = load_state() {
    let source_info = if state.source == "prebuilt" {
        if let Some(ref registry) = state.registry {
            format!("prebuilt from {}", registry)
        } else {
            "prebuilt".to_string()
        }
    } else {
        "built from source".to_string()
    };
    println!("Image src:   {}", style(&source_info).dim());
}
```

The display should look like:
```
Image:       ghcr.io/prizz/opencode-cloud:latest
CLI:         v1.0.12
Image ver:   v1.0.12
Image src:   prebuilt from ghcr.io
```

Or for built images:
```
Image:       ghcr.io/prizz/opencode-cloud:latest
CLI:         v1.0.12
Image ver:   v1.0.12
Image src:   built from source
```
  </action>
  <verify>
1. `just fmt && just lint` - Code is clean
2. `just test` - Tests pass
3. `just build` - Builds successfully
  </verify>
  <done>Status command shows image provenance from state file</done>
</task>

</tasks>

<verification>
1. `just fmt` - Code is formatted
2. `just lint` - No clippy warnings
3. `just test` - All tests pass
4. `just build` - Release build succeeds
5. Manual verification:
   - `occ setup` shows image source prompt
   - `occ config show` displays image_source value
   - `occ update --help` works
   - `occ status` shows Image src line when state exists
</verification>

<success_criteria>
- Setup wizard asks for image source (prebuilt or build)
- Wizard saves choice to config.image_source
- `occ update` pulls if image_source=prebuilt, builds if image_source=build
- Update shows informational message about which method is being used
- `occ status` shows "Image src: prebuilt from ghcr.io" or "Image src: built from source"
- All existing functionality continues to work
</success_criteria>

<output>
After completion, create `.planning/phases/15-prebuilt-image-option/15-03-SUMMARY.md`
</output>
