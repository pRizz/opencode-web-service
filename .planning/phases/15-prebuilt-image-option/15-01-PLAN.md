---
phase: 15-prebuilt-image-option
plan: 01
type: execute
wave: 1
depends_on: []
files_modified:
  - packages/core/src/config/schema.rs
  - packages/core/src/config/mod.rs
  - packages/core/src/docker/mod.rs
  - packages/core/src/docker/state.rs
  - packages/core/src/lib.rs
autonomous: true

must_haves:
  truths:
    - "Config accepts image_source field with values 'prebuilt' or 'build'"
    - "Config accepts update_check field with values 'always', 'once', or 'never'"
    - "Image provenance can be saved and loaded from local state file"
    - "Existing configs without new fields use sensible defaults"
  artifacts:
    - path: "packages/core/src/config/schema.rs"
      provides: "image_source and update_check fields with defaults"
      contains: "image_source"
    - path: "packages/core/src/docker/state.rs"
      provides: "ImageState struct and save/load functions"
      exports: ["ImageState", "save_state", "load_state", "get_state_path"]
  key_links:
    - from: "packages/core/src/docker/state.rs"
      to: "packages/core/src/config/paths.rs"
      via: "get_data_dir for state file location"
      pattern: "get_data_dir"
---

<objective>
Add configuration fields and image state tracking for prebuilt image support.

Purpose: Enable the CLI to remember user's image source preference and track where the current image came from (prebuilt from GHCR/Docker Hub vs built locally).

Output: Config schema with new fields, image state module for provenance tracking.
</objective>

<execution_context>
@~/.claude/get-shit-done/workflows/execute-plan.md
@~/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/15-prebuilt-image-option/15-CONTEXT.md
@.planning/phases/15-prebuilt-image-option/15-RESEARCH.md
@packages/core/src/config/schema.rs
@packages/core/src/config/mod.rs
@packages/core/src/config/paths.rs
@packages/core/src/docker/mod.rs
</context>

<tasks>

<task type="auto">
  <name>Task 1: Add image_source and update_check to config schema</name>
  <files>packages/core/src/config/schema.rs</files>
  <action>
Add two new fields to the Config struct:

1. `image_source: String` - Source of Docker image
   - Values: "prebuilt" | "build"
   - Default: "prebuilt" (via default_image_source function)
   - Use `#[serde(default = "default_image_source")]`
   - Doc comment: "Source of Docker image: 'prebuilt' (pull from registry) or 'build' (compile locally)"

2. `update_check: String` - When to check for updates
   - Values: "always" | "once" | "never"
   - Default: "always" (via default_update_check function)
   - Use `#[serde(default = "default_update_check")]`
   - Doc comment: "When to check for updates: 'always' (every start), 'once' (once per version), 'never'"

Add default functions:
```rust
fn default_image_source() -> String {
    "prebuilt".to_string()
}

fn default_update_check() -> String {
    "always".to_string()
}
```

Update Default impl to include:
- `image_source: default_image_source()`
- `update_check: default_update_check()`

Add tests:
- test_default_config_image_fields: Verify defaults are prebuilt/always
- test_serialize_deserialize_with_image_fields: Roundtrip with custom values
- test_image_fields_default_on_missing: Old configs get defaults (like cockpit fields test)
  </action>
  <verify>Run `just test` - all tests pass including new ones</verify>
  <done>Config schema accepts image_source and update_check with proper defaults</done>
</task>

<task type="auto">
  <name>Task 2: Create image state module for provenance tracking</name>
  <files>packages/core/src/docker/state.rs, packages/core/src/docker/mod.rs, packages/core/src/lib.rs</files>
  <action>
Create new file `packages/core/src/docker/state.rs`:

```rust
//! Image state tracking for provenance information
//!
//! Tracks where the current Docker image came from (prebuilt or built)
//! and which registry it was pulled from.

use serde::{Deserialize, Serialize};
use std::path::PathBuf;
use chrono::{DateTime, Utc};

/// Image provenance state
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct ImageState {
    /// Image version (e.g., "1.0.12")
    pub version: String,
    /// Source: "prebuilt" or "build"
    pub source: String,
    /// Registry if prebuilt: "ghcr.io" or "docker.io", None for build
    #[serde(skip_serializing_if = "Option::is_none")]
    pub registry: Option<String>,
    /// When the image was acquired (ISO8601)
    pub acquired_at: String,
}

impl ImageState {
    /// Create a new ImageState for a prebuilt image
    pub fn prebuilt(version: &str, registry: &str) -> Self {
        Self {
            version: version.to_string(),
            source: "prebuilt".to_string(),
            registry: Some(registry.to_string()),
            acquired_at: Utc::now().to_rfc3339(),
        }
    }

    /// Create a new ImageState for a locally built image
    pub fn built(version: &str) -> Self {
        Self {
            version: version.to_string(),
            source: "build".to_string(),
            registry: None,
            acquired_at: Utc::now().to_rfc3339(),
        }
    }
}

/// Get the path to the image state file
pub fn get_state_path() -> Option<PathBuf> {
    crate::config::paths::get_data_dir().map(|p| p.join("image-state.json"))
}

/// Save image state to disk
pub fn save_state(state: &ImageState) -> anyhow::Result<()> {
    let path = get_state_path()
        .ok_or_else(|| anyhow::anyhow!("Could not determine state path"))?;

    // Ensure parent directory exists
    if let Some(parent) = path.parent() {
        std::fs::create_dir_all(parent)?;
    }

    let json = serde_json::to_string_pretty(state)?;
    std::fs::write(&path, json)?;
    Ok(())
}

/// Load image state from disk
pub fn load_state() -> Option<ImageState> {
    let path = get_state_path()?;
    let content = std::fs::read_to_string(&path).ok()?;
    serde_json::from_str(&content).ok()
}

/// Clear image state (e.g., after image removal)
pub fn clear_state() -> anyhow::Result<()> {
    if let Some(path) = get_state_path() {
        if path.exists() {
            std::fs::remove_file(&path)?;
        }
    }
    Ok(())
}

#[cfg(test)]
mod tests {
    use super::*;

    #[test]
    fn test_image_state_prebuilt() {
        let state = ImageState::prebuilt("1.0.12", "ghcr.io");
        assert_eq!(state.version, "1.0.12");
        assert_eq!(state.source, "prebuilt");
        assert_eq!(state.registry, Some("ghcr.io".to_string()));
        assert!(!state.acquired_at.is_empty());
    }

    #[test]
    fn test_image_state_built() {
        let state = ImageState::built("1.0.12");
        assert_eq!(state.version, "1.0.12");
        assert_eq!(state.source, "build");
        assert!(state.registry.is_none());
    }

    #[test]
    fn test_image_state_serialize_deserialize() {
        let state = ImageState::prebuilt("1.0.12", "docker.io");
        let json = serde_json::to_string(&state).unwrap();
        let parsed: ImageState = serde_json::from_str(&json).unwrap();
        assert_eq!(state.version, parsed.version);
        assert_eq!(state.source, parsed.source);
        assert_eq!(state.registry, parsed.registry);
    }

    #[test]
    fn test_get_state_path() {
        let path = get_state_path();
        assert!(path.is_some());
        let p = path.unwrap();
        assert!(p.to_string_lossy().contains("image-state.json"));
    }
}
```

Update `packages/core/src/docker/mod.rs`:
- Add `pub mod state;`
- Add to re-exports: `pub use state::{ImageState, clear_state, get_state_path, load_state, save_state};`

Update `packages/core/src/lib.rs` if needed to ensure docker module is public (it should already be).
  </action>
  <verify>Run `just test` - all tests pass including new state module tests</verify>
  <done>Image state module exists with save/load functions and provenance tracking</done>
</task>

</tasks>

<verification>
1. `just fmt` - Code is formatted
2. `just lint` - No clippy warnings
3. `just test` - All tests pass
4. `just build` - Release build succeeds
5. Verify config migration: Create a minimal config `{"version": 1}` and confirm it loads with default image_source/update_check
</verification>

<success_criteria>
- Config schema has image_source (default: "prebuilt") and update_check (default: "always") fields
- ImageState struct can track version, source, registry, and timestamp
- save_state() persists to ~/.local/share/opencode-cloud/image-state.json
- load_state() returns Option<ImageState> from disk
- All existing tests continue to pass
- New tests verify roundtrip serialization and defaults
</success_criteria>

<output>
After completion, create `.planning/phases/15-prebuilt-image-option/15-01-SUMMARY.md`
</output>
