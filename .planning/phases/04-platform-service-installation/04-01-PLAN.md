---
phase: 04-platform-service-installation
plan: 01
type: execute
wave: 1
depends_on: []
files_modified:
  - packages/core/src/config/schema.rs
  - packages/core/src/platform/mod.rs
  - packages/core/src/lib.rs
  - packages/core/Cargo.toml
autonomous: true

must_haves:
  truths:
    - "Config can store boot_mode (user or system)"
    - "Config can store restart_retries count"
    - "Config can store restart_delay in seconds"
    - "Platform detection returns correct service manager type"
  artifacts:
    - path: "packages/core/src/config/schema.rs"
      provides: "Extended Config struct with service registration fields"
      contains: "boot_mode"
    - path: "packages/core/src/platform/mod.rs"
      provides: "ServiceManager trait and platform detection"
      exports: ["ServiceManager", "get_service_manager", "InstallResult"]
  key_links:
    - from: "packages/core/src/lib.rs"
      to: "packages/core/src/platform/mod.rs"
      via: "pub mod platform"
      pattern: "pub mod platform"
---

<objective>
Extend the configuration schema to support service registration settings and create the platform abstraction layer for systemd/launchd integration.

Purpose: Establishes the foundation for platform-specific service managers by defining the ServiceManager trait and extending Config with boot_mode, restart_retries, and restart_delay fields.

Output: Extended Config schema and platform module with ServiceManager trait.
</objective>

<execution_context>
@~/.claude/get-shit-done/workflows/execute-plan.md
@~/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/phases/04-platform-service-installation/04-CONTEXT.md
@.planning/phases/04-platform-service-installation/04-RESEARCH.md
@packages/core/src/config/schema.rs
@packages/core/src/lib.rs
@packages/core/Cargo.toml
</context>

<tasks>

<task type="auto">
  <name>Task 1: Extend Config Schema with Service Registration Fields</name>
  <files>packages/core/src/config/schema.rs</files>
  <action>
Add three new fields to the Config struct:

1. `boot_mode: String` - "user" (default) or "system"
   - Default: "user" via `default_boot_mode()` function
   - Serde default attribute

2. `restart_retries: u32` - Number of restart attempts on crash
   - Default: 3 via `default_restart_retries()` function
   - Serde default attribute

3. `restart_delay: u32` - Seconds between restart attempts
   - Default: 5 via `default_restart_delay()` function
   - Serde default attribute

Update Default impl to include these fields.

Add unit tests:
- Test default values (boot_mode="user", restart_retries=3, restart_delay=5)
- Test deserialization with missing optional fields uses defaults
- Test serialize/deserialize roundtrip with new fields
  </action>
  <verify>`just test` passes with new config tests</verify>
  <done>Config struct has boot_mode, restart_retries, restart_delay fields with defaults</done>
</task>

<task type="auto">
  <name>Task 2: Create Platform Module with ServiceManager Trait</name>
  <files>packages/core/src/platform/mod.rs, packages/core/src/lib.rs, packages/core/Cargo.toml</files>
  <action>
Create new platform module at `packages/core/src/platform/mod.rs`:

1. Define ServiceConfig struct to hold install configuration:
   ```rust
   pub struct ServiceConfig {
       pub executable_path: PathBuf,
       pub restart_retries: u32,
       pub restart_delay: u32,
       pub boot_mode: String,  // "user" or "system"
   }
   ```

2. Define InstallResult struct for install feedback:
   ```rust
   pub struct InstallResult {
       pub service_file_path: PathBuf,
       pub service_name: String,
       pub started: bool,
       pub requires_root: bool,
   }
   ```

3. Define ServiceManager trait:
   ```rust
   pub trait ServiceManager: Send + Sync {
       fn install(&self, config: &ServiceConfig) -> Result<InstallResult>;
       fn uninstall(&self) -> Result<()>;
       fn is_installed(&self) -> Result<bool>;
       fn service_file_path(&self) -> PathBuf;
       fn service_name(&self) -> &str;
   }
   ```

4. Add platform detection function:
   ```rust
   pub fn get_service_manager() -> Result<Box<dyn ServiceManager>> {
       #[cfg(target_os = "linux")]
       {
           // Return stub that will be implemented in 04-02
           Err(anyhow!("systemd manager not yet implemented"))
       }
       #[cfg(target_os = "macos")]
       {
           // Return stub that will be implemented in 04-03
           Err(anyhow!("launchd manager not yet implemented"))
       }
       #[cfg(not(any(target_os = "linux", target_os = "macos")))]
       {
           Err(anyhow!("Unsupported platform for service registration"))
       }
   }
   ```

5. Add platform availability check:
   ```rust
   pub fn is_service_registration_supported() -> bool {
       cfg!(any(target_os = "linux", target_os = "macos"))
   }
   ```

6. Update `packages/core/src/lib.rs`:
   - Add `pub mod platform;`
   - Add re-export: `pub use platform::{ServiceManager, ServiceConfig, InstallResult, get_service_manager, is_service_registration_supported};`

7. Cargo.toml already has `anyhow` workspace dep - no changes needed.
  </action>
  <verify>`just build` compiles on current platform, `just test` passes</verify>
  <done>Platform module exists with ServiceManager trait, ServiceConfig, InstallResult, and platform detection stub</done>
</task>

</tasks>

<verification>
- `just fmt && just lint && just test && just build` all pass
- Config schema includes boot_mode, restart_retries, restart_delay
- Platform module exports ServiceManager trait and types
- Platform detection function exists (returns error until implementations added)
</verification>

<success_criteria>
- Config can be serialized/deserialized with new fields
- Platform module is accessible via `opencode_cloud_core::platform`
- ServiceManager trait is defined and can be used as trait object
- Existing tests continue to pass
</success_criteria>

<output>
After completion, create `.planning/phases/04-platform-service-installation/04-01-SUMMARY.md`
</output>
