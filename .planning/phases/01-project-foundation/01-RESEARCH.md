# Phase 1: Project Foundation - Research

**Researched:** 2026-01-18
**Domain:** Monorepo setup, CLI scaffolding, config management, Rust + Node bindings
**Confidence:** HIGH

## Summary

This research covers the technical foundations for Phase 1: establishing a polyglot monorepo with Rust core + Node.js bindings architecture. The key architectural decision is using **NAPI-RS** to create Node.js native addons from Rust, allowing a single Rust core library (`packages/core`) to serve both the Rust CLI and the Node.js CLI via bindings.

The standard approach for 2025/2026 is:
- **pnpm workspaces** for Node.js package management
- **Cargo workspaces** for Rust package management
- **NAPI-RS** for Rust-to-Node bindings with prebuilt binary distribution
- **just** for cross-language task orchestration
- **clap** for Rust CLI, thin Node wrapper calling into Rust bindings
- **jsonc-parser** (Rust) and Microsoft's **jsonc-parser** (Node) for JSONC config
- **directories** crate and **env-paths** npm package for XDG-compliant paths
- **pidlock** crate for singleton enforcement

**Primary recommendation:** Build Rust core first, then expose to Node via NAPI-RS bindings. This avoids duplicate implementations and ensures feature parity.

## Standard Stack

The established libraries/tools for this domain:

### Core Build Tooling
| Library | Version | Purpose | Why Standard |
|---------|---------|---------|--------------|
| pnpm | 9.x | Node package manager | Fast, efficient for monorepos, workspace protocol |
| Cargo | 1.82+ | Rust package manager | Required for Rust 2024 edition |
| just | 1.31+ | Task runner | Modules support, cross-platform, simple syntax |
| NAPI-RS | 3.x | Rust-to-Node bindings | Industry standard, prebuilt binary support |

### Rust Dependencies
| Library | Version | Purpose | Why Standard |
|---------|---------|---------|--------------|
| clap | 4.5 | CLI framework | Derive macros, subcommand aliases |
| tokio | 1.43 LTS | Async runtime | Required for async operations |
| serde | 1.0 | Serialization | Universal Rust standard |
| jsonc-parser | 0.29 | JSONC parsing | Serde integration via `parse_to_serde_value` |
| directories | 5 | XDG paths | Cross-platform, well-maintained |
| pidlock | latest | Singleton enforcement | Cross-platform, stale lock detection |
| thiserror | 2.0 | Error types | Clean error definitions |
| anyhow | 2.0 | Error handling | Ergonomic application errors |
| tracing | 0.1 | Logging | Structured logging standard |
| console | 0.16 | Terminal styling | Part of console-rs ecosystem |

### Node.js Dependencies
| Library | Version | Purpose | Why Standard |
|---------|---------|---------|--------------|
| @napi-rs/cli | 3.x | Build Rust bindings | Official NAPI-RS tooling |
| jsonc-parser | latest | JSONC parsing | Microsoft's official parser |
| env-paths | latest | XDG paths | Sindre Sorhus, cross-platform |
| commander | 14.x | CLI framework | Optional thin wrapper only |

### Alternatives Considered
| Instead of | Could Use | Tradeoff |
|------------|-----------|----------|
| pnpm | npm/yarn | pnpm more efficient for monorepos |
| just | make | just is simpler, cross-platform |
| NAPI-RS | node-bindgen | NAPI-RS has better tooling, prebuilt support |
| jsonc-parser | serde_json5 | jsonc-parser is more targeted, actively maintained |
| directories | cross-xdg | directories follows platform conventions |
| pidlock | pidfile2 | pidlock has stale detection, cross-platform |

**Installation:**

```bash
# Root: pnpm and just
npm install -g pnpm
brew install just  # or cargo install just

# Node packages
pnpm install -D @napi-rs/cli jsonc-parser env-paths commander
```

```toml
# Cargo.toml
[dependencies]
clap = { version = "4.5", features = ["derive"] }
tokio = { version = "1.43", features = ["rt-multi-thread", "macros"] }
serde = { version = "1.0", features = ["derive"] }
jsonc-parser = { version = "0.29", features = ["serde"] }
directories = "5"
pidlock = "0.1"
thiserror = "2"
anyhow = "2"
tracing = "0.1"
tracing-subscriber = { version = "0.3", features = ["env-filter"] }
console = "0.16"

# For NAPI-RS bindings
[lib]
crate-type = ["cdylib"]

[dependencies]
napi = { version = "2", features = ["tokio_rt", "napi9"] }
napi-derive = "2"
```

## Architecture Patterns

### Recommended Project Structure
```
opencode-cloud/
├── packages/
│   ├── core/                    # Rust core library + NAPI bindings
│   │   ├── Cargo.toml
│   │   ├── src/
│   │   │   ├── lib.rs          # Library exports
│   │   │   ├── config/         # Config management
│   │   │   ├── cli/            # CLI logic (shared)
│   │   │   └── singleton/      # PID lock handling
│   │   ├── npm/                # Generated by napi
│   │   │   ├── darwin-arm64/
│   │   │   ├── darwin-x64/
│   │   │   ├── linux-x64-gnu/
│   │   │   └── win32-x64-msvc/
│   │   └── index.js            # Auto-generated loader
│   ├── cli-rust/               # Rust CLI binary
│   │   ├── Cargo.toml
│   │   └── src/
│   │       └── main.rs         # Thin wrapper over core
│   └── cli-node/               # Node CLI (optional thin wrapper)
│       ├── package.json
│       └── src/
│           └── index.ts        # Calls into @opencode-cloud/core
├── schemas/
│   └── config.schema.json      # JSON Schema for config
├── docker/                     # Docker assets (later phases)
├── Cargo.toml                  # Workspace root
├── pnpm-workspace.yaml
├── package.json                # Root package.json
└── justfile                    # Task orchestration
```

### Pattern 1: Rust Core with NAPI Bindings

**What:** Single Rust implementation exposed to both Rust CLI and Node.js via NAPI-RS.

**When to use:** When you want feature parity between Rust and Node CLIs without duplication.

**Example:**
```rust
// packages/core/src/lib.rs
use napi_derive::napi;

pub mod config;
pub mod singleton;

// Export for Rust consumers
pub use config::{Config, load_config, save_config};
pub use singleton::{acquire_lock, release_lock};

// NAPI bindings for Node consumers
#[napi]
pub fn get_version() -> String {
    env!("CARGO_PKG_VERSION").to_string()
}

#[napi]
pub async fn load_config_js() -> napi::Result<String> {
    let config = config::load_config()
        .map_err(|e| napi::Error::from_reason(e.to_string()))?;
    serde_json::to_string(&config)
        .map_err(|e| napi::Error::from_reason(e.to_string()))
}
```

### Pattern 2: XDG-Compliant Config Paths

**What:** Use platform-appropriate directories for config and data.

**When to use:** Always for user-facing config/data storage.

**Example (Rust):**
```rust
// packages/core/src/config/paths.rs
use directories::ProjectDirs;
use std::path::PathBuf;

pub fn get_config_dir() -> Option<PathBuf> {
    // Returns:
    // Linux: ~/.config/opencode-cloud/
    // macOS: ~/.config/opencode-cloud/ (per CONTEXT.md decision)
    // Windows: %APPDATA%\opencode-cloud\

    // For XDG-style on macOS (as decided), use custom logic
    #[cfg(target_os = "macos")]
    {
        dirs::home_dir().map(|h| h.join(".config").join("opencode-cloud"))
    }

    #[cfg(not(target_os = "macos"))]
    {
        ProjectDirs::from("", "", "opencode-cloud")
            .map(|dirs| dirs.config_dir().to_path_buf())
    }
}

pub fn get_data_dir() -> Option<PathBuf> {
    // Linux/macOS: ~/.local/share/opencode-cloud/
    // Windows: %LOCALAPPDATA%\opencode-cloud\

    #[cfg(any(target_os = "linux", target_os = "macos"))]
    {
        dirs::home_dir().map(|h| h.join(".local").join("share").join("opencode-cloud"))
    }

    #[cfg(target_os = "windows")]
    {
        dirs::data_local_dir().map(|d| d.join("opencode-cloud"))
    }
}

pub fn get_config_path() -> Option<PathBuf> {
    get_config_dir().map(|d| d.join("config.json"))
}

pub fn get_pid_path() -> Option<PathBuf> {
    get_data_dir().map(|d| d.join("opencode-cloud.pid"))
}
```

### Pattern 3: Singleton with PID Lock

**What:** Ensure only one instance runs per host using PID file with stale detection.

**When to use:** For services that must be unique per machine.

**Example (Rust):**
```rust
// packages/core/src/singleton/mod.rs
use pidlock::{Pidlock, PidlockError};
use std::path::PathBuf;
use thiserror::Error;

#[derive(Error, Debug)]
pub enum SingletonError {
    #[error("Another instance is already running (PID: {0})")]
    AlreadyRunning(u32),
    #[error("Failed to create lock: {0}")]
    LockError(String),
    #[error("Invalid lock path")]
    InvalidPath,
}

pub struct InstanceLock {
    lock: Pidlock,
}

impl InstanceLock {
    pub fn acquire(pid_path: &PathBuf) -> Result<Self, SingletonError> {
        let lock = Pidlock::new_validated(pid_path)
            .map_err(|e| SingletonError::LockError(e.to_string()))?;

        match lock.acquire() {
            Ok(()) => Ok(Self { lock }),
            Err(PidlockError::LockExists) => {
                // Read existing PID for error message
                let pid = std::fs::read_to_string(pid_path)
                    .ok()
                    .and_then(|s| s.trim().parse().ok())
                    .unwrap_or(0);
                Err(SingletonError::AlreadyRunning(pid))
            }
            Err(e) => Err(SingletonError::LockError(e.to_string())),
        }
    }
}

// Lock auto-releases on drop via pidlock
```

### Pattern 4: JSONC Config with Schema Validation

**What:** Parse JSON with comments, validate against schema.

**When to use:** User-editable config files.

**Example (Rust):**
```rust
// packages/core/src/config/mod.rs
use jsonc_parser::{parse_to_serde_value, ParseOptions};
use serde::{Deserialize, Serialize};

#[derive(Debug, Serialize, Deserialize)]
pub struct Config {
    pub version: u32,
    pub port: u16,
    pub bind: String,
    pub auto_restart: bool,
}

impl Default for Config {
    fn default() -> Self {
        Self {
            version: 1,
            port: 8080,
            bind: "localhost".to_string(),
            auto_restart: true,
        }
    }
}

pub fn parse_config(content: &str) -> anyhow::Result<Config> {
    let options = ParseOptions {
        allow_comments: true,
        allow_trailing_commas: true,
        allow_loose_object_property_names: false,
    };

    let value = parse_to_serde_value(content, &options)?
        .ok_or_else(|| anyhow::anyhow!("Empty config file"))?;

    let config: Config = serde_json::from_value(value)?;
    Ok(config)
}
```

### Pattern 5: clap Subcommands with Aliases

**What:** CLI with subcommands and short aliases.

**When to use:** All CLI implementations.

**Example:**
```rust
// packages/cli-rust/src/main.rs
use clap::{Parser, Subcommand};

#[derive(Parser)]
#[command(name = "opencode-cloud")]
#[command(version, about = "Manage your opencode cloud service")]
struct Cli {
    #[command(subcommand)]
    command: Commands,

    /// Increase verbosity
    #[arg(short, long, global = true)]
    verbose: bool,

    /// Suppress non-error output
    #[arg(short, long, global = true)]
    quiet: bool,

    /// Disable colors
    #[arg(long, global = true)]
    no_color: bool,
}

#[derive(Subcommand)]
enum Commands {
    /// Start the service
    #[command(visible_alias = "up")]
    Start,

    /// Stop the service
    #[command(visible_alias = "down")]
    Stop,

    /// Show service status
    #[command(visible_alias = "st")]
    Status,

    /// Manage configuration
    #[command(subcommand)]
    Config(ConfigCommands),
}

#[derive(Subcommand)]
enum ConfigCommands {
    /// Show current configuration
    Show,

    /// Set a configuration value
    Set {
        key: String,
        value: String,
    },

    /// Reset configuration to defaults
    Reset,
}
```

### Anti-Patterns to Avoid

- **Duplicate implementations:** Don't implement the same logic in both Rust and Node. Use NAPI-RS bindings.
- **Hardcoded paths:** Never use `/etc/` or `C:\Program Files\`. Use directories/env-paths.
- **Global config:** Don't use `~/.opencoderc`. Use proper XDG directories.
- **Synchronous file ops in Node:** Always use async when calling into Rust core.
- **Manual platform checks:** Let the libraries handle platform detection.

## Don't Hand-Roll

Problems that look simple but have existing solutions:

| Problem | Don't Build | Use Instead | Why |
|---------|-------------|-------------|-----|
| Cross-platform paths | Manual `if darwin/linux/windows` | `directories` crate | Edge cases (no $HOME, network drives, WSL) |
| JSONC parsing | Regex to strip comments | `jsonc-parser` | Comments in strings, escapes, trailing commas |
| PID locking | `fs::write(pid)` | `pidlock` | Atomic operations, stale detection, cleanup on crash |
| Node bindings | node-ffi, wasm | NAPI-RS | Type safety, performance, prebuilt binaries |
| CLI parsing | Manual arg parsing | clap | Help generation, completions, validation |
| Async runtime | `std::thread` for async | tokio | Ecosystem compatibility, efficiency |

**Key insight:** Each of these has subtle edge cases. PID files need atomic creation, stale detection, and cleanup. JSONC has comment-in-string edge cases. Cross-platform paths have dozens of edge cases per platform.

## Common Pitfalls

### Pitfall 1: NAPI-RS Async Misunderstanding
**What goes wrong:** Blocking the Node.js event loop with synchronous Rust code.
**Why it happens:** NAPI-RS runs Rust code on the main thread by default.
**How to avoid:** Use `#[napi]` with `async` functions and the `tokio_rt` feature.
**Warning signs:** Node process hangs, unresponsive to Ctrl+C.

### Pitfall 2: Cargo Workspace vs pnpm Workspace Confusion
**What goes wrong:** Expecting `pnpm build` to build Rust code.
**Why it happens:** They're separate build systems with no automatic coordination.
**How to avoid:** Use `just` to orchestrate both. Never assume one triggers the other.
**Warning signs:** Stale binaries, "module not found" errors.

### Pitfall 3: macOS XDG Path Inconsistency
**What goes wrong:** Using `~/Library/Application Support` instead of `~/.config`.
**Why it happens:** The `directories` crate follows macOS conventions by default.
**How to avoid:** Per CONTEXT.md decision, manually construct `~/.config/opencode-cloud/` on macOS.
**Warning signs:** Config not found after specifying `~/.config` path.

### Pitfall 4: PID File Left Behind
**What goes wrong:** Stale PID file prevents new instance from starting.
**Why it happens:** Process killed with SIGKILL, or panic without cleanup.
**How to avoid:** `pidlock` handles this with process existence checks.
**Warning signs:** "Already running" error when no process exists.

### Pitfall 5: NAPI-RS Package Naming
**What goes wrong:** npm spam detection blocks publishing.
**Why it happens:** NAPI-RS creates many platform packages (darwin-arm64, linux-x64, etc.).
**How to avoid:** Use npm scope: `@opencode-cloud/core`, `@opencode-cloud/core-darwin-arm64`.
**Warning signs:** Publish failures, 403 errors from npm registry.

### Pitfall 6: Rust 2024 Edition MSRV
**What goes wrong:** CI fails or users can't build.
**Why it happens:** Rust 2024 requires Rust 1.85+, some CI images have older versions.
**How to avoid:** Set `rust-version = "1.85"` in Cargo.toml, use `actions-rust-lang/setup-rust-toolchain@v1`.
**Warning signs:** "unknown edition `2024`" error.

### Pitfall 7: JSONC vs JSON5 Confusion
**What goes wrong:** Using JSON5 features that JSONC doesn't support.
**Why it happens:** JSON5 and JSONC are different specs.
**How to avoid:** JSONC only supports `//` and `/* */` comments, plus trailing commas. No unquoted keys or hex numbers.
**Warning signs:** Parse errors on valid JSON5.

## Code Examples

Verified patterns from official sources:

### Justfile for Polyglot Monorepo
```just
# justfile - Root task orchestration

# Default recipe
default: list

# List available recipes
list:
    @just --list

# Build everything
build: build-rust build-node

# Build Rust packages
build-rust:
    cargo build --workspace

# Build Node packages (including NAPI bindings)
build-node:
    cd packages/core && pnpm build
    pnpm -r build

# Run all tests
test: test-rust test-node

test-rust:
    cargo test --workspace

test-node:
    pnpm -r test

# Lint everything
lint: lint-rust lint-node

lint-rust:
    cargo fmt --all -- --check
    cargo clippy --all-targets --all-features -- -D warnings

lint-node:
    pnpm -r lint

# Format everything
fmt:
    cargo fmt --all
    pnpm -r format

# Clean all build artifacts
clean:
    cargo clean
    pnpm -r clean

# Development mode
dev:
    cargo watch -x "build --package opencode-cloud-core"

# Release build
release:
    cargo build --workspace --release
    cd packages/core && pnpm build --release
```

### pnpm-workspace.yaml
```yaml
packages:
  - 'packages/*'
```

### Root Cargo.toml
```toml
[workspace]
resolver = "2"
members = [
    "packages/core",
    "packages/cli-rust",
]

[workspace.package]
version = "0.1.0"
edition = "2024"
rust-version = "1.85"
license = "MIT"
repository = "https://github.com/user/opencode-cloud"

[workspace.dependencies]
clap = { version = "4.5", features = ["derive"] }
tokio = { version = "1.43", features = ["rt-multi-thread", "macros"] }
serde = { version = "1.0", features = ["derive"] }
serde_json = "1.0"
jsonc-parser = { version = "0.29", features = ["serde"] }
directories = "5"
pidlock = "0.1"
thiserror = "2"
anyhow = "2"
tracing = "0.1"
tracing-subscriber = { version = "0.3", features = ["env-filter"] }
console = "0.16"
napi = { version = "2", features = ["tokio_rt", "napi9"] }
napi-derive = "2"
```

### packages/core/Cargo.toml
```toml
[package]
name = "opencode-cloud-core"
version.workspace = true
edition.workspace = true
rust-version.workspace = true
license.workspace = true

[lib]
crate-type = ["cdylib", "rlib"]  # cdylib for NAPI, rlib for Rust CLI

[dependencies]
clap.workspace = true
tokio.workspace = true
serde.workspace = true
serde_json.workspace = true
jsonc-parser.workspace = true
directories.workspace = true
pidlock.workspace = true
thiserror.workspace = true
anyhow.workspace = true
tracing.workspace = true
console.workspace = true
napi.workspace = true
napi-derive.workspace = true

[build-dependencies]
napi-build = "2"
```

### packages/core/package.json
```json
{
  "name": "@opencode-cloud/core",
  "version": "0.1.0",
  "main": "index.js",
  "types": "index.d.ts",
  "napi": {
    "name": "core",
    "triples": {
      "additional": [
        "aarch64-apple-darwin",
        "x86_64-apple-darwin",
        "x86_64-unknown-linux-gnu",
        "x86_64-pc-windows-msvc"
      ]
    }
  },
  "scripts": {
    "build": "napi build --platform --release",
    "build:debug": "napi build --platform",
    "prepublishOnly": "napi prepublish -t npm"
  },
  "devDependencies": {
    "@napi-rs/cli": "^3.0.0-alpha.0"
  },
  "optionalDependencies": {
    "@opencode-cloud/core-darwin-arm64": "0.1.0",
    "@opencode-cloud/core-darwin-x64": "0.1.0",
    "@opencode-cloud/core-linux-x64-gnu": "0.1.0",
    "@opencode-cloud/core-win32-x64-msvc": "0.1.0"
  }
}
```

## State of the Art

| Old Approach | Current Approach | When Changed | Impact |
|--------------|------------------|--------------|--------|
| node-gyp compilation | NAPI-RS prebuilt binaries | 2023-2024 | No compile on install, faster npm install |
| npm/yarn workspaces | pnpm workspaces | 2022-2023 | Better monorepo support, faster installs |
| Make for tasks | just | 2023-2024 | Simpler syntax, cross-platform |
| Rust 2021 edition | Rust 2024 edition | Feb 2025 | New language features, MSRV-aware resolver |
| Manual PID files | pidlock crate | 2024 | Proper stale detection, cross-platform |

**Deprecated/outdated:**
- **node-ffi**: Use NAPI-RS instead for performance and type safety
- **async-std**: Discontinued March 2025, use tokio
- **structopt**: Merged into clap, use clap derive
- **app_dirs**: Unmaintained, use directories

## Open Questions

Things that couldn't be fully resolved:

1. **Version Source of Truth**
   - What we know: Need single version for npm + cargo lockstep
   - What's unclear: Best practice for single source (VERSION file vs Cargo.toml vs package.json)
   - Recommendation: Use VERSION file at root, read by build scripts

2. **Node CLI Wrapper Necessity**
   - What we know: NAPI-RS allows calling Rust from Node
   - What's unclear: Whether to have a thin Node CLI or just the Rust binary
   - Recommendation: For npx, need minimal Node package that calls bindings

3. **Pre-commit Hook Tooling**
   - What we know: Need lint/format checks before commit
   - What's unclear: husky vs lefthook vs pre-commit (Python)
   - Recommendation: Use lefthook (Go binary, no deps)

## Sources

### Primary (HIGH confidence)
- [NAPI-RS Official Docs](https://napi.rs/) - Getting started, release distribution
- [clap docs.rs](https://docs.rs/clap/latest/clap/_derive/index.html) - Derive API, subcommands
- [jsonc-parser docs.rs](https://docs.rs/jsonc-parser/latest/jsonc_parser/) - Serde integration
- [pidlock docs.rs](https://docs.rs/pidlock) - Cross-platform PID locking
- [directories crates.io](https://crates.io/crates/directories) - XDG path resolution
- [just manual](https://just.systems/man/en/modules1190.html) - Modules, imports
- [Rust 2024 Edition Guide](https://doc.rust-lang.org/edition-guide/rust-2024/index.html) - Edition features
- [pnpm workspaces](https://pnpm.io/workspaces) - Workspace configuration

### Secondary (MEDIUM confidence)
- [env-paths npm](https://www.npmjs.com/package/env-paths) - Node XDG paths
- [Microsoft jsonc-parser npm](https://www.npmjs.com/package/jsonc-parser) - Node JSONC parsing
- [proper-lockfile npm](https://www.npmjs.com/package/proper-lockfile) - Node file locking

### Tertiary (LOW confidence)
- Various blog posts on monorepo patterns - used for general guidance only

## Metadata

**Confidence breakdown:**
- Standard stack: HIGH - All libraries are well-documented, widely used
- Architecture (NAPI-RS pattern): HIGH - Official NAPI-RS documentation and examples
- Pitfalls: MEDIUM - Based on issue trackers and community reports
- Just modules: MEDIUM - Relatively new feature (1.31.0)

**Research date:** 2026-01-18
**Valid until:** 2026-02-18 (30 days for stable ecosystem)
