---
phase: 01-project-foundation
plan: 02
type: execute
wave: 2
depends_on: ["01-01"]
files_modified:
  - packages/core/Cargo.toml
  - packages/core/src/lib.rs
  - packages/core/src/config/mod.rs
  - packages/core/src/config/paths.rs
  - packages/core/src/config/schema.rs
  - packages/core/src/singleton/mod.rs
  - packages/cli-rust/src/main.rs
  - schemas/config.schema.json
  - schemas/config.example.jsonc
autonomous: true

must_haves:
  truths:
    - "Running CLI for first time creates config directory at ~/.config/opencode-cloud/"
    - "Running CLI creates config.json with default values if it does not exist"
    - "Config file is valid JSONC (supports comments)"
    - "Invalid config causes CLI to exit with clear error message"
    - "Second CLI instance fails with 'already running' error showing existing PID"
    - "Stale PID file (process not running) is cleaned up automatically"
  artifacts:
    - path: "packages/core/src/config/mod.rs"
      provides: "Config loading/saving"
      exports: ["Config", "load_config", "save_config"]
    - path: "packages/core/src/config/paths.rs"
      provides: "XDG-compliant path resolution"
      exports: ["get_config_dir", "get_data_dir", "get_config_path", "get_pid_path"]
    - path: "packages/core/src/singleton/mod.rs"
      provides: "PID lock singleton enforcement"
      exports: ["InstanceLock", "SingletonError"]
    - path: "schemas/config.schema.json"
      provides: "JSON Schema for config validation"
      contains: "$schema"
    - path: "schemas/config.example.jsonc"
      provides: "Example config with comments"
      contains: "//"
  key_links:
    - from: "packages/cli-rust/src/main.rs"
      to: "packages/core/src/config/mod.rs"
      via: "load_config call"
      pattern: "load_config"
    - from: "packages/cli-rust/src/main.rs"
      to: "packages/core/src/singleton/mod.rs"
      via: "acquire_lock call"
      pattern: "InstanceLock::acquire"
    - from: "packages/core/src/config/mod.rs"
      to: "packages/core/src/config/paths.rs"
      via: "path resolution"
      pattern: "get_config_path"
---

<objective>
Implement configuration management with XDG-compliant paths, JSONC parsing, schema validation, and singleton enforcement via PID lock.

Purpose: Enables persistent configuration and ensures only one CLI instance runs per host (CONS-01). This is foundational for all service management commands.

Output: CLI that loads/creates config at `~/.config/opencode-cloud/config.json` and enforces single-instance via PID lock.
</objective>

<execution_context>
@~/.claude/get-shit-done/workflows/execute-plan.md
@~/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/01-project-foundation/01-CONTEXT.md
@.planning/phases/01-project-foundation/01-RESEARCH.md
@.planning/phases/01-project-foundation/01-01-SUMMARY.md
</context>

<tasks>

<task type="auto">
  <name>Task 1: Implement XDG-compliant path resolution and config schema</name>
  <files>
    packages/core/src/config/mod.rs
    packages/core/src/config/paths.rs
    packages/core/src/config/schema.rs
    packages/core/src/lib.rs
    schemas/config.schema.json
    schemas/config.example.jsonc
  </files>
  <action>
Create config management infrastructure:

1. **packages/core/src/config/paths.rs** - XDG path resolution:
   Per CONTEXT.md decisions, use `~/.config/opencode-cloud/` on both Linux AND macOS (not macOS Library paths).

   ```rust
   use std::path::PathBuf;

   pub fn get_config_dir() -> Option<PathBuf> {
       // Linux and macOS: ~/.config/opencode-cloud/
       // Windows: %APPDATA%\opencode-cloud\
       #[cfg(any(target_os = "linux", target_os = "macos"))]
       {
           dirs::home_dir().map(|h| h.join(".config").join("opencode-cloud"))
       }
       #[cfg(target_os = "windows")]
       {
           dirs::config_dir().map(|d| d.join("opencode-cloud"))
       }
   }

   pub fn get_data_dir() -> Option<PathBuf> {
       // Linux/macOS: ~/.local/share/opencode-cloud/
       // Windows: %LOCALAPPDATA%\opencode-cloud\
       #[cfg(any(target_os = "linux", target_os = "macos"))]
       {
           dirs::home_dir().map(|h| h.join(".local").join("share").join("opencode-cloud"))
       }
       #[cfg(target_os = "windows")]
       {
           dirs::data_local_dir().map(|d| d.join("opencode-cloud"))
       }
   }

   pub fn get_config_path() -> Option<PathBuf> {
       get_config_dir().map(|d| d.join("config.json"))
   }

   pub fn get_pid_path() -> Option<PathBuf> {
       get_data_dir().map(|d| d.join("opencode-cloud.pid"))
   }
   ```

   Note: Use `dirs` crate (add to dependencies) for home_dir, config_dir, data_local_dir.

2. **packages/core/src/config/schema.rs** - Config struct and defaults:
   ```rust
   use serde::{Deserialize, Serialize};

   #[derive(Debug, Clone, Serialize, Deserialize)]
   pub struct Config {
       /// Config file version for migrations
       pub version: u32,
       /// Port for web UI (default: 8080)
       pub port: u16,
       /// Bind address (default: "localhost")
       pub bind: String,
       /// Auto-restart on crash (default: true)
       pub auto_restart: bool,
   }

   impl Default for Config {
       fn default() -> Self {
           Self {
               version: 1,
               port: 8080,
               bind: "localhost".to_string(),
               auto_restart: true,
           }
       }
   }
   ```

3. **packages/core/src/config/mod.rs** - Config loading/saving with JSONC:
   - `pub fn load_config() -> anyhow::Result<Config>` - Load from config path, create default if missing
   - `pub fn save_config(config: &Config) -> anyhow::Result<()>` - Save to config path, create backup first
   - `pub fn ensure_config_dir() -> anyhow::Result<PathBuf>` - Create config dir if missing
   - Use jsonc_parser for parsing (allow comments)
   - Validate: reject unknown keys (use serde's deny_unknown_fields)
   - Create config.json.bak before modifying existing config

4. **Update packages/core/src/lib.rs**:
   - Add `pub mod config;`
   - Re-export: `pub use config::{Config, load_config, save_config, paths};`

5. **schemas/config.schema.json** - JSON Schema:
   ```json
   {
     "$schema": "https://json-schema.org/draft/2020-12/schema",
     "$id": "https://github.com/user/opencode-cloud/schemas/config.schema.json",
     "title": "opencode-cloud configuration",
     "type": "object",
     "properties": {
       "version": { "type": "integer", "minimum": 1, "description": "Config file version" },
       "port": { "type": "integer", "minimum": 1, "maximum": 65535, "default": 8080 },
       "bind": { "type": "string", "default": "localhost" },
       "auto_restart": { "type": "boolean", "default": true }
     },
     "required": ["version"],
     "additionalProperties": false
   }
   ```

6. **schemas/config.example.jsonc** - Example with comments:
   ```jsonc
   {
     // Config file version - do not modify
     "version": 1,

     // Port for the opencode web UI
     "port": 8080,

     // Bind address
     // "localhost" = local only (secure default)
     // "0.0.0.0" = network accessible (requires explicit opt-in)
     "bind": "localhost",

     // Auto-restart service on crash
     "auto_restart": true
   }
   ```

7. **Update packages/core/Cargo.toml**:
   - Add `dirs = "5"` to dependencies (for home_dir, etc.)
  </action>
  <verify>
    - `cargo build -p opencode-cloud-core` compiles
    - `cat schemas/config.schema.json` shows valid JSON Schema
    - `cat schemas/config.example.jsonc` shows commented example
  </verify>
  <done>
    Config module compiles with path resolution, schema struct, and JSONC loading. JSON Schema and example file exist.
  </done>
</task>

<task type="auto">
  <name>Task 2: Implement singleton enforcement via PID lock</name>
  <files>
    packages/core/Cargo.toml
    packages/core/src/singleton/mod.rs
    packages/core/src/lib.rs
  </files>
  <action>
Implement singleton enforcement using a PID file with stale detection:

1. **Update packages/core/Cargo.toml**:
   - Note: pidlock crate has issues, implement simple PID lock manually
   - Add `sysinfo = "0.32"` for process existence check

2. **packages/core/src/singleton/mod.rs**:
   Implement PID lock with stale detection (manual, since pidlock crate can be unreliable):

   ```rust
   use std::fs::{self, File};
   use std::io::{Read, Write};
   use std::path::PathBuf;
   use thiserror::Error;
   use sysinfo::{System, Pid};

   #[derive(Error, Debug)]
   pub enum SingletonError {
       #[error("Another instance is already running (PID: {0})")]
       AlreadyRunning(u32),
       #[error("Failed to create lock directory: {0}")]
       CreateDirFailed(String),
       #[error("Failed to create lock file: {0}")]
       LockFailed(String),
       #[error("Invalid lock file path")]
       InvalidPath,
   }

   pub struct InstanceLock {
       pid_path: PathBuf,
   }

   impl InstanceLock {
       pub fn acquire(pid_path: PathBuf) -> Result<Self, SingletonError> {
           // Ensure parent directory exists
           if let Some(parent) = pid_path.parent() {
               fs::create_dir_all(parent)
                   .map_err(|e| SingletonError::CreateDirFailed(e.to_string()))?;
           }

           // Check if PID file exists
           if pid_path.exists() {
               // Read existing PID
               let mut file = File::open(&pid_path)
                   .map_err(|e| SingletonError::LockFailed(e.to_string()))?;
               let mut contents = String::new();
               file.read_to_string(&mut contents)
                   .map_err(|e| SingletonError::LockFailed(e.to_string()))?;

               if let Ok(pid) = contents.trim().parse::<u32>() {
                   // Check if process is still running
                   if is_process_running(pid) {
                       return Err(SingletonError::AlreadyRunning(pid));
                   }
                   // Stale PID file - process not running, remove it
                   tracing::info!("Removing stale PID file (PID {} not running)", pid);
               }
               // Remove stale/invalid PID file
               fs::remove_file(&pid_path)
                   .map_err(|e| SingletonError::LockFailed(e.to_string()))?;
           }

           // Write our PID
           let mut file = File::create(&pid_path)
               .map_err(|e| SingletonError::LockFailed(e.to_string()))?;
           write!(file, "{}", std::process::id())
               .map_err(|e| SingletonError::LockFailed(e.to_string()))?;

           Ok(Self { pid_path })
       }

       pub fn release(self) {
           // Explicitly release - also happens on Drop
           let _ = fs::remove_file(&self.pid_path);
       }
   }

   impl Drop for InstanceLock {
       fn drop(&mut self) {
           let _ = fs::remove_file(&self.pid_path);
       }
   }

   fn is_process_running(pid: u32) -> bool {
       let sys = System::new_all();
       sys.process(Pid::from(pid as usize)).is_some()
   }
   ```

3. **Update packages/core/src/lib.rs**:
   - Add `pub mod singleton;`
   - Re-export: `pub use singleton::{InstanceLock, SingletonError};`
  </action>
  <verify>
    - `cargo build -p opencode-cloud-core` compiles
    - Unit test: Create lock, verify PID file exists, drop lock, verify PID file removed
  </verify>
  <done>
    Singleton module compiles with PID lock acquisition, stale detection, and automatic cleanup on drop
  </done>
</task>

<task type="auto">
  <name>Task 3: Wire config and singleton into CLI</name>
  <files>
    packages/cli-rust/src/main.rs
  </files>
  <action>
Update the Rust CLI to use config loading and singleton enforcement:

1. **packages/cli-rust/src/main.rs**:
   - On startup (before processing commands), load config:
     - If config doesn't exist, create default and inform user of location
     - If config is invalid JSONC, exit with clear error
   - Add `config` subcommand group (placeholder for Phase 5):
     - `config show` - Display current config (implement now)
     - `config set <key> <value>` - Placeholder (stub that says "not yet implemented")
   - For commands that manage the service (start, stop, restart - not yet implemented), acquire singleton lock
   - For read-only commands (config show, status, version), do NOT acquire lock
   - When acquiring lock fails, show rich error:
     ```
     Error: Another opencode-cloud instance is already running

       PID: 12345
       Lock file: ~/.local/share/opencode-cloud/opencode-cloud.pid

     To stop the other instance, run: occ stop
     ```
   - Display config/data paths on `--verbose`

   Structure:
   ```rust
   #[derive(Subcommand)]
   enum Commands {
       /// Manage configuration
       #[command(subcommand)]
       Config(ConfigCommands),
       // Future: Start, Stop, Status, etc.
   }

   #[derive(Subcommand)]
   enum ConfigCommands {
       /// Show current configuration
       Show,
       /// Set a configuration value
       Set {
           key: String,
           value: String,
       },
   }

   fn main() -> anyhow::Result<()> {
       // Initialize tracing
       tracing_subscriber::fmt::init();

       let cli = Cli::parse();

       // Load config (creates default if missing)
       let config_path = opencode_cloud_core::config::paths::get_config_path()
           .ok_or_else(|| anyhow::anyhow!("Could not determine config path"))?;
       let config = opencode_cloud_core::load_config()?;

       if cli.verbose {
           eprintln!("Config: {}", config_path.display());
           eprintln!("Data: {}", opencode_cloud_core::config::paths::get_data_dir()
               .map(|p| p.display().to_string())
               .unwrap_or_else(|| "unknown".to_string()));
       }

       match cli.command {
           Some(Commands::Config(cmd)) => handle_config(cmd, &config),
           None => {
               // Show help if no command
               Cli::parse_from(["opencode-cloud", "--help"]);
               Ok(())
           }
       }
   }
   ```
  </action>
  <verify>
    - `cargo run -p opencode-cloud -- config show` displays current config as JSON
    - First run creates `~/.config/opencode-cloud/config.json`
    - `cargo run -p opencode-cloud -- --verbose config show` shows paths
    - Edit config.json to be invalid JSON, run CLI, get clear error
  </verify>
  <done>
    CLI loads config on startup, creates default if missing, shows config paths with --verbose, and config show command works
  </done>
</task>

</tasks>

<verification>
Overall phase checks:

1. `cargo build --workspace` - All packages compile
2. `cargo run -p opencode-cloud -- --version` - Shows version
3. `cargo run -p opencode-cloud -- config show` - Shows default config
4. First run creates `~/.config/opencode-cloud/config.json`
5. Verify config.json content matches schema defaults
6. Add invalid key to config.json, run CLI, expect clear error about unknown field
7. `cat schemas/config.schema.json` - Valid JSON Schema exists
8. `cat schemas/config.example.jsonc` - Example with comments exists

Singleton test (manual):
1. In one terminal, add a sleep to main.rs and run CLI
2. In another terminal, try to run CLI - should fail with "already running" error
3. Kill first process with SIGKILL (not graceful)
4. Run CLI again - should succeed (stale lock detected and cleaned)
</verification>

<success_criteria>
- Config is loaded from `~/.config/opencode-cloud/config.json`
- Missing config is created with defaults
- Invalid config (unknown keys, bad JSON) causes clear error
- `config show` displays current configuration
- JSON Schema exists at `schemas/config.schema.json`
- Example config exists at `schemas/config.example.jsonc`
- Singleton enforcement prevents duplicate instances
- Stale PID files are automatically cleaned up
- Verbose mode shows config and data paths
</success_criteria>

<output>
After completion, create `.planning/phases/01-project-foundation/01-02-SUMMARY.md`
</output>
